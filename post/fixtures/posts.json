[{"model": "post.post", "pk": 1, "fields": {"title": "How to protect your server on Ubuntu 16.04 with Fail2Ban with email alerts and GeoIP filter", "slug": "how-protect-your-server-ubuntu-1604-fail2ban-email-alerts-geoip-filter", "excerpt": "This tutorial describes the shortcut to gaining essential security level for your fresh Ubuntu server. The reason why you should do so is that almost every ip address in the world is being bruteforced 24/7 by large botnets and amount of bots and sophistication of attacks are increasing dramatically. Nowadays the cyber security is paramount.", "body": "<h3>Introduction</h3>\n<p>This tutorial describes the shortcut to gaining essential security level for your fresh Ubuntu server. The reason why you should do so is that almost every ip address in the world is being bruteforced 24/7 by large botnets and amount of bots and sophistication of attacks are increasing dramatically. Nowadays the cyber security is paramount.</p>\n<h3>Contents</h3>\n<p>This tutorial includes three parts:</p>\n<ol>\n<li>Disabling root login remotely (essential)</li>\n<li>Add cryptographic key authentication (recommended)</li>\n<li>Limit your SSH logins using GeoIP (optional)</li>\n</ol>\n<p>Let\u2019s start with disabling root login remotely. This requires to log in, create a new user which will be used for remote login and configuring ssh service.</p>\n<p><em>Note:</em> If you don\u2019t know how to copy/paste in terminal, use usual commands (<code>CTRL+V, CTRL+C</code> on linux and windows) with <code>SHIFT</code> pressed. Read <a href=\"https://stackoverflow.com/questions/761807/how-to-copy-and-paste-from-terminal-with-keyboard\">this</a> answer on stackoverflow for more information.</p>\n<h2>Disabling root login remotely (essential)</h2>\n<h3>Login to your server</h3>\n<p>This command will help you to login to your server as <code>root</code> user. Replace the <em>server</em> with your server ip address or domain name.</p>\n<pre class=\"command-line language-bash\" data-user=\"user\" data-host=\"localhost\"><code class=\" language-bash\">\nssh root@server\n</code></pre>\n\n<p>As a result, you now must be connected to the server and logged in as root. You must see something like this:</p>\n<pre><code class=\"language-bash\">Welcome to Ubuntu 16.04.3 LTS (GNU/Linux 4.4.0-042stab120.18 x86_64)\n\n * Documentation:  https://help.ubuntu.com\n * Management:     https://landscape.canonical.com\n * Support:        https://ubuntu.com/advantage\nLast login: Wed Sep 13 03:00:23 2017 from 12.345.67.890\n\n[root@server ~]#\n</code></pre>\n\n<h3>Create a new user</h3>\n<p>Then add a new user to the system which will be used instead of root for login. Replace username in the examples below with a name that you like. After executing the command <code>adduser</code> you will be asked for new user\u2019s password. Enter a strong password and, optionally, fill in any of the additional information if you would like. This is not required and you can just hit <code>ENTER</code> in any field you wish to skip.</p>\n<pre class=\"command-line language-bash\" data-user=\"root\" data-host=\"server\"><code class=\" language-bash\">\nadduser username\n</code></pre>\n\n<p>Now, we have a new user account with regular account privileges. However, we may sometimes need to do administrative tasks.</p>\n<p>To avoid having to log out of our normal user and log back in as the root account, we can set up what is known as \"superuser\" or root privileges for our normal account. This will allow our normal user to run commands with administrative privileges by putting the word <code>sudo</code> before each command.</p>\n<pre class=\"command-line language-bash\" data-user=\"root\" data-host=\"server\"><code class=\" language-bash\">\nusermod -aG sudo username\n</code></pre>\n\n<p>Now your user can run commands with superuser privileges! For more information about how this works, check out <a href=\"https://www.digitalocean.com/community/tutorials/how-to-edit-the-sudoers-file-on-ubuntu-and-centos\">this sudoers tutorial</a>.</p>\n<p>To disable root SSH login, edit <code>/etc/ssh/sshd_config</code> with your favorite text editor. </p>\n<p>The most common terminal text editor amongst developers is Vim. It\u2019s a bit complicated but can save you a lot of time. So I provided a few tips for you who didn\u2019t used it before.</p>\n<p>Run the following command (vi is alias for vim):</p>\n<pre class=\"command-line language-bash\" data-user=\"root\" data-host=\"server\"><code class=\" language-bash\">\nvi /etc/ssh/sshd_config\n</code></pre>\n\n<p>As you press enter you will see the Vim text editor. What you should know about Vim is that:</p>\n<ol>\n<li>Vim has several modes available. Just keep in mind that there are <strong>command</strong> mode and <strong>other</strong> modes. </li>\n<li>You can use only <strong>command</strong> and <strong>input</strong> modes to do basic text editing.</li>\n<li>By default Vim is in <strong>command</strong> mode. To return to command mode from any press <code>ESC</code>. </li>\n<li>Vim has its commands. Most commands start with colon (<code>:</code> key).</li>\n<li>To exit Vim run <code>:q</code> command.</li>\n<li>To edit a file you should use <strong>input</strong> mode. Press <code>i</code> key to enter the mode from the command mode. </li>\n<li>To write to a file use command <code>:w</code>. </li>\n<li>You can combine commands, i.e., fire <code>:wq</code> and you will save file on exit.</li>\n<li>To search for a string hit <code>/</code> in command mode and then input the string, hit enter.</li>\n</ol>\n<h4>Vim command reference</h4>\n<p>save: <code>:w</code><br />\nsave and exit: <code>:wq</code><br />\nexit: <code>:q</code><br />\nforce: <code>!</code> (example <code>:w!</code>, <code>:q!</code>)<br />\nvertical split: open a document and then type <code>:vsplit /path-to-document/document</code> and this will open the specified document and split the screen so you can see both documents.<br />\ncopy: <code>y</code><br />\ncopy a line: <code>yy</code><br />\npaste: <code>p</code><br />\ncut: <code>d</code><br />\ncut a line: <code>dd</code></p>\n<p><a href=\"https://www.howtoforge.com/vim-basics\">Here</a> is vim tutorial. You can find a lot of helpful video tutorials on youtube.</p>\n<p>Enter the input mode, edit line and save on exit.</p>\n<p>Change this line:</p>\n<pre><code class=\"language-none\">#PermitRootLogin yes\n</code></pre>\n\n<p>Edit to this:</p>\n<pre><code class=\"language-none\">PermitRootLogin no\n</code></pre>\n\n<p><strong>Ensure that you are logged into the box with another shell before restarting sshd to avoid locking yourself out of the server.</strong></p>\n<pre><code class=\"language-none\">[root@server ~]# /etc/init.d/sshd restart\nStopping sshd: [ OK ]\nStarting sshd: [ OK ]\n[root@server ~]#\n</code></pre>\n\n<p>That\u2019s it. Now you can logout using <code>exit</code> command and try to login with new user credentials.</p>\n<p>If you wish your server be more secured, follow the next step of the tutorial.</p>\n<h2>Add cryptographic key authentication (recommended)</h2>\n<p>If you already have a key that you want to use, skip to the Copy the Public Key step.</p>\n<p>If you do not already have an SSH key pair, which consists of a public and private key, you need to generate one. You will need this key to work with such services as <a href=\"https://bitbucket.org/\">bitbucket</a> or <a href=\"https://github.com\">github</a>. </p>\n<h3>Generate key pair</h3>\n<p>Run this command on your local machine to generate the key pair.</p>\n<pre class=\"command-line language-bash\" data-user=\"user\" data-host=\"localhost\"><code class=\" language-bash\">\nssh-keygen\n</code></pre>\n\n<p>You will be asked few questions after that the key pair will be generated.</p>\n<p><em>Note:</em> you will be asked for a passphrase, which if you provide one will be asked when login to the server. If not, then you won\u2019t have to type the passphrase every time you login.</p>\n<p>This generates a private key, id_rsa, and a public key, id_rsa.pub, in the .ssh directory of the localuser's home directory. Remember that the private key should not be shared with anyone who should not have access to your servers!</p>\n<h3>Copy the public key</h3>\n<h4>Option 1: Use ssh-copy-id</h4>\n<p>If your local machine has the <code>ssh-copy-id</code> script installed, you can use it to install your public key to any user that you have login credentials for.</p>\n<p>Run the <code>ssh-copy-id</code> script by specifying the user and IP address of the server that you want to install the key on, like this:</p>\n<pre class=\"command-line language-bash\" data-user=\"user\" data-host=\"localhost\"><code class=\" language-bash\">\nssh-copy-id username@server\n</code></pre>\n\n<p>After providing your password at the prompt, your public key will be added to the remote user's <code>.ssh/authorized_keys</code> file. The corresponding private key can now be used to log into the server.</p>\n<h4>Option 2: Manually Install the Key</h4>\n<p>Assuming you generated an SSH key pair using the previous step, use the following command at the terminal of your local machine to print your public key (<code>id_rsa.pub</code>):</p>\n<pre class=\"command-line language-bash\" data-user=\"user\" data-host=\"localhost\"><code class=\" language-bash\">\ncat ~/.ssh/id_rsa.pub\n</code></pre>\n\n<p>This should print your public SSH key, which should look something like the following:</p>\n<pre><code class=\"language-none\">id_rsa.pub contents\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDBGTO0tsVejssuaYR5R3Y/i73SppJAhme1dH7W2c47d4gOqB4izP0+fRLfvbz/tnXFz4iOP/H6eCV05hqUhF+KYRxt9Y8tVMrpDZR2l75o6+xSbUOMu6xN+uVF0T9XzKcxmzTmnV7Na5up3QM3DoSRYX/EP3utr2+zAqpJIfKPLdA74w7g56oYWI9blpnpzxkEd3edVJOivUkpZ4JoenWManvIaSdMTJXMy3MtlQhva+j9CgguyVbUkdzK9KKEuah+pFZvaugtebsU+bllPTB0nlXGIJk98Ie9ZtxuY3nCKneB+KjKiXrAvXUPCI9mWkYS/1rggpFmu3HbXBnWSUdf user@machine.local\n</code></pre>\n\n<p>Select the public key, and copy it to your clipboard.</p>\n<p>To enable the use of SSH key to authenticate as the new remote user, you must add the public key to a special file in the user's home directory.</p>\n<p>On the <strong>server</strong>, as the <strong>root</strong> user, enter the following command to temporarily switch to the new user (substitute your own user name):</p>\n<pre class=\"command-line language-bash\" data-user=\"root\" data-host=\"server\"><code class=\" language-bash\">\nsu - username\n</code></pre>\n\n<p>Now you will be in your new user's home directory.</p>\n<p>Create a new directory called .ssh and restrict its permissions with the following commands:</p>\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\nmkdir ~/.ssh\nchmod 700 ~/.ssh\n</code></pre>\n\n<p>Now open a file in <code>.ssh</code> called <code>authorized_keys</code> with a text editor. We will use <code>vim</code> to edit the file:</p>\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\nvim ~/.ssh/authorized_keys\n</code></pre>\n\n<p>Hit <code>i</code>, insert your public key (which should be in your clipboard) by pasting it into the editor (<code>CTRL+SHIFT+V</code>) and save on exit hitting <code>ESC</code>, then <code>:wq</code>.</p>\n<p>Now restrict the permissions of the authorized_keys file with this command:</p>\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\nchmod 600 ~/.ssh/authorized_keys\n</code></pre>\n\n<p>Type this command <strong>once</strong> to return to the <code>root</code> user:</p>\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\nexit\n</code></pre>\n\n<p>Now your public key is installed, and you can use SSH keys to log in as your user.</p>\n<h2>Disable password authentication</h2>\n<p>To disable password authentication on your server, follow these steps.</p>\n<p>As root or your new sudo user, open the SSH daemon configuration:</p>\n<pre class=\"command-line language-bash\" data-user=\"root\" data-host=\"server\"><code class=\" language-bash\">\nvim /etc/ssh/sshd_config\n</code></pre>\n\n<p>Find the line that specifies PasswordAuthentication, uncomment it by deleting the preceding #, then change its value to \"no\". It should look like this after you have made the change:</p>\n<pre class=\"language-none\"><code class=\" language-none\">\nPasswordAuthentication no\n</code></pre>\n\n<p>Here are two other settings that are important for key-only authentication and are set by default. If you haven't modified this file before, you do not need to change these settings:</p>\n<pre class=\"language-none\"><code class=\" language-none\">\nPubkeyAuthentication yes\nChallengeResponseAuthentication no\n</code></pre>\n\n<p>Type this to reload the SSH daemon:</p>\n<pre class=\"command-line language-bash\" data-user=\"root\" data-host=\"server\"><code class=\" language-bash\">\nsystemctl reload sshd\n</code></pre>\n\n<p>Password authentication is now disabled. Your server is now only accessible with SSH key authentication.</p>\n<h2>Set up firewall</h2>\n<p>Ubuntu 16.04 servers can use the UFW firewall to make sure only connections to certain services are allowed. We can set up a basic firewall very easily using this application.</p>\n<p>Different applications can register their profiles with UFW upon installation. These profiles allow UFW to manage these applications by name. OpenSSH, the service allowing us to connect to our server now, has a profile registered with UFW.</p>\n<p>You can see this by typing:<br />\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\"><br />\nsudo ufw app list<br />\n</code></pre></p>\n<p>We need to make sure that the firewall allows SSH connections so that we can log back in next time. We can allow these connections by typing:</p>\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\nsudo ufw allow OpenSSH\n</code></pre>\n\n<p>Afterwards, we can enable the firewall by typing:</p>\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\nsudo ufw enable\n</code></pre>\n\n<p>Type \"y\" and press ENTER to proceed. You can see that SSH connections are still allowed by typing:</p>\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\nsudo ufw status\n</code></pre>\n\n<p>If you install and configure additional services, you will need to adjust the firewall settings to allow acceptable traffic in. You can learn some common UFW operations in <a href=\"https://www.digitalocean.com/community/tutorials/ufw-essentials-common-firewall-rules-and-commands\">this guide</a>.</p>\n<h2>Set up fail2ban</h2>\n<p>A service called fail2ban can mitigate this problem by creating rules that can automatically alter your iptables firewall configuration based on a predefined number of unsuccessful login attempts. This will allow your server to respond to illegitimate access attempts without intervention from you.</p>\n<h3>Install and configure fail2ban</h3>\n<p>Type the following commands to install fail2ban:</p>\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\nsudo apt-get update\nsudo apt-get install fail2ban\n</code></pre>\n\n<p>The fail2ban service keeps its configuration files in the <code>/etc/fail2ban</code> directory. There is a file with defaults called <code>jail.conf</code>.</p>\n<p>Since this file can be modified by package upgrades, we should not edit this file in-place, but rather copy it so that we can make our changes safely. In order for these two files to operate together successfully, it is best to only include the settings you wish to override in the <code>jail.local</code> file. All default options will be taken from the <code>jail.conf</code> file.</p>\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\nawk '{ printf \"# \"; print; }' /etc/fail2ban/jail.conf | sudo tee /etc/fail2ban/jail.local\n</code></pre>\n\n<p>You will want to evaluate the <code>destemail</code>, <code>sendername</code>, and <code>mta</code> settings if you wish to configure <strong>email alerts</strong>. The <code>destemail</code> parameter sets the email address that should receive ban messages. The <code>sendername</code> sets the value of the \"From\" field in the email. The <code>mta</code> parameter configures what mail service will be used to send mail. Again, add these to the jail.local file, under the [DEFAULT] header and set to the proper values if you wish to adjust them.</p>\n<p><em>Note:</em> the mail service (<code>mta</code>) must be configured properly to send emails. <a href=\"https://linuxconfig.org/configuring-gmail-as-sendmail-email-relay\">This tutorial</a> can help you configure the <code>sendmail</code> service. <em>It is good practice to configure email alerts for most people do not check <code>/var/log/auth.log</code> file even once a month.</em></p>\n<pre class=\"language-none\"><code class=\" language-none\">\n[DEFAULT]\n. . .\naction = $(action_)s\n. . .\n</code></pre>\n\n<p>This parameter configures the action that fail2ban takes when it wants to institute a ban. The value action_ is defined in the file shortly before this parameter. The default action is to simply configure the firewall to reject traffic from the offending host until the ban time elapses.</p>\n<p>If you would like to configure email alerts, add or uncomment the action item to the jail.local file and change its value from action_ to action_mw. If you want the email to include the relevant log lines, you can change it to action_mwl. Make sure you have the appropriate mail settings configured if you choose to use mail alerts.</p>\n<p>We're going to configure a auto-banning policy for SSH and Nginx, just as we described above. We want fail2ban to email us when an IP is banned.</p>\n<p>If you don't already have it, you'll need nginx, since we're going to be monitoring its logs, and you'll need sendmail to mail us notifications. We'll also grab iptables-persistent to allow the server to automatically set up our firewall rules at boot. These can be acquired from Ubuntu's default repositories:</p>\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\nsudo apt-get update\nsudo apt-get install nginx sendmail iptables-persistent\n</code></pre>\n\n<p>Stop the fail2ban service for a moment so that we can establish a base firewall without the rules it adds:</p>\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\nsudo service fail2ban stop\n</code></pre>\n\n<p>When that is finished, we should implement a default firewall.</p>\n<p>We're going to tell it to allow established connections, traffic generated by the server itself, traffic destined for our SSH and web server ports. We will drop all other traffic. We can set this basic firewall up by typing:</p>\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\nsudo iptables -A INPUT -i lo -j ACCEPT\nsudo iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\nsudo iptables -A INPUT -p tcp --dport 22 -j ACCEPT\nsudo iptables -A INPUT -p tcp -m multiport --dports 80,443 -j ACCEPT\nsudo iptables -A INPUT -j DROP\n</code></pre>\n\n<p>These commands will implement the above policy. We can see our current firewall rules by typing:</p>\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\nsudo iptables -S\n</code></pre>\n\n<p>You can save the firewalls so that they survive a reboot by typing:<br />\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\"><br />\nsudo dpkg-reconfigure iptables-persistent<br />\n</code></pre></p>\n<p>Afterwards, you can restart fail2ban to implement the wrapping rules:</p>\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\nsudo service fail2ban start\n</code></pre>\n\n<p>We can see our current firewall rules by typing:<br />\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\"><br />\nsudo iptables -S<br />\n</code></pre></p>\n<p>If you want to read more on how to set up firewall with fail2ban go <a href=\"https://www.digitalocean.com/community/tutorials/how-to-protect-ssh-with-fail2ban-on-ubuntu-14-04\">here</a>.</p>\n<p>The next step is optional.</p>\n<h2>Limit your SSH logins using GeoIP (optional)</h2>\n<p>As i mentioned before, you should take some actions to protect the server (primarily, against botnets, which scan almost all available ips and try to break into the server and take control). Most often you will see incoming <a href=\"https://www.digitalocean.com/community/questions/is-anyone-else-being-brute-forced-by-chinese-ip-addresses\">bruteforce attacks from Chinese bots</a>.</p>\n<h3>Install</h3>\n<p>Install GeoIP using the following coman:</p>\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\nsudo apt update\nsudo apt install geoip-bin geoip-database\n</code></pre>\n\n<p>Make sure it works by doing a simple test:</p>\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\n geoiplookup 8.8.8.8\n</code></pre>\n\n<p>Create the script to filter requests and cut unneeded. <br />\nOn ubuntu you can see messages from sshd serrvice in <code>/var/log/syslog</code> file.</p>\n<h3>Configure</h3>\n<p>Save this file in <code>/usr/local/bin/sshfilter.sh</code>:<br />\n<pre class=\"language-bash line-numbers\"><code class=\" language-bash line-numbers\"></p>\n<h1>!/bin/bash</h1>\n<h1>UPPERCASE space-separated country codes to ACCEPT</h1>\n<p>ALLOW_COUNTRIES=\"NZ AU\"</p>\n<p>if [ $# -ne 1 ]; then<br />\n  echo \"Usage:  <code>basename $0</code> <ip>\" 1&gt;&amp;2<br />\n  exit 0 # return true in case of config issue<br />\nfi</p>\n<p>COUNTRY=<code>/usr/bin/geoiplookup $1 | awk -F \": \" '{ print $2 }' | awk -F \",\" '{ print $1 }' | head -n 1</code></p>\n<p>[[ $COUNTRY = \"IP Address not found\" || $ALLOW_COUNTRIES =~ $COUNTRY ]] &amp;&amp; RESPONSE=\"ALLOW\" || RESPONSE=\"DENY\"</p>\n<p>if [ $RESPONSE = \"ALLOW\" ]<br />\nthen<br />\n  exit 0<br />\nelse<br />\n  logger \"$RESPONSE sshd connection from $1 ($COUNTRY)\"<br />\n  exit 1<br />\nfi<br />\n</code></pre></p>\n<p>Edit the ALLOW_COUNTRIES to include a list of country codes you want your SSH server to accept connections from. <a href=\"http://www.nationsonline.org/oneworld/country_code_list.htm\">Here</a> you can find country codes.</p>\n<p>The last things we need to do is tell the ssh daemon (sshd) to deny all connections (by default) and to run this script to determine whether the connection should be allowed or not.</p>\n<p>In /etc/hosts.deny add the line:<br />\n<pre class=\"language-none\"><code class=\" language-none\"><br />\nsshd: ALL<br />\n</code></pre></p>\n<p>and in /etc/hosts.allow add the line<br />\n<pre class=\"language-none\"><code class=\" language-none\"><br />\nsshd: ALL: aclexec /usr/local/bin/sshfilter.sh %a<br />\n</code></pre></p>\n<h3>Testing</h3>\n<p>Obviously you want to test that this is working before you are accidentally logged out of your system. On the console I can do a test with the 8.8.8.8 which I happen to know is from the US, and in my case should be DENIED access. So:</p>\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\n/usr/local/bin/sshfilter.sh 8.8.8.8\n</code></pre>\n\n<p>The script will not return anything visible, however in /var/log/messages I have the result:<br />\n<pre class=\"language-none\"><code class=\" language-none\"><br />\nJun 26 17:02:37 pi root: DENY sshd connection from 8.8.8.8 (US)<br />\n</code></pre></p>\n<h3>Updating GeoIP</h3>\n<p>In order to make sure you are up-to-date with your GeoIP (free) country database, you will need to write another script which you can run as a monthly root cron job.</p>\n<p>Please note that if you just installed the GeoIP database, or you have never manually updated it (it does not auto-update), then you should run the following script manually after installing it! The default database that gets installed is several years old and very inaccurate.</p>\n<pre class=\"language-bash line-numbers\"><code class=\" language-bash line-numbers\">\n#!/bin/bash\n\ncd /tmp\nwget -q https://geolite.maxmind.com/download/geoip/database/GeoLiteCountry/GeoIP.dat.gz\nif [ -f GeoIP.dat.gz ]\nthen\n    gzip -d GeoIP.dat.gz\n    rm -f /usr/share/GeoIP/GeoIP.dat\n    mv -f GeoIP.dat /usr/share/GeoIP/GeoIP.dat\nelse\n    echo \"The GeoIP library could not be downloaded and updated\"\nfi\n</code></pre>\n\n<h2>Sources:</h2>\n<ol>\n<li><a href=\"https://www.digitalocean.com/community/tutorials/initial-server-setup-with-ubuntu-16-04\">Initial Server Setup with Ubuntu 16.04</a></li>\n<li><a href=\"https://www.howtoforge.com/vim-basics\">Vim Basics Tutorial</a></li>\n<li><a href=\"https://www.digitalocean.com/community/tutorials/how-to-protect-ssh-with-fail2ban-on-ubuntu-14-04\">How To Protect SSH with Fail2Ban on Ubuntu 14.04</a></li>\n<li><a href=\"https://www.axllent.org/docs/view/ssh-geoip/\">Limit your SSH logins using GeoIP</a></li>\n</ol>", "markdown": "### Introduction\r\n\r\nThis tutorial describes the shortcut to gaining essential security level for your fresh Ubuntu server. The reason why you should do so is that almost every ip address in the world is being bruteforced 24/7 by large botnets and amount of bots and sophistication of attacks are increasing dramatically. Nowadays the cyber security is paramount.\r\n\r\n### Contents\r\n\r\nThis tutorial includes three parts:\r\n\r\n1. Disabling root login remotely (essential)\r\n2. Add cryptographic key authentication (recommended)\r\n3. Limit your SSH logins using GeoIP (optional)\r\n\r\nLet\u2019s start with disabling root login remotely. This requires to log in, create a new user which will be used for remote login and configuring ssh service.\r\n\r\n*Note:* If you don\u2019t know how to copy/paste in terminal, use usual commands (```CTRL+V, CTRL+C``` on linux and windows) with ```SHIFT``` pressed. Read [this](https://stackoverflow.com/questions/761807/how-to-copy-and-paste-from-terminal-with-keyboard) answer on stackoverflow for more information.\r\n\r\n\r\n## Disabling root login remotely (essential)\r\n\r\n### Login to your server\r\n\r\nThis command will help you to login to your server as ```root``` user. Replace the *server* with your server ip address or domain name.\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"user\" data-host=\"localhost\"><code class=\" language-bash\">\r\nssh root@server\r\n</code></pre>\r\n\r\nAs a result, you now must be connected to the server and logged in as root. You must see something like this:\r\n\r\n```language-bash\r\nWelcome to Ubuntu 16.04.3 LTS (GNU/Linux 4.4.0-042stab120.18 x86_64)\r\n\r\n * Documentation:  https://help.ubuntu.com\r\n * Management:     https://landscape.canonical.com\r\n * Support:        https://ubuntu.com/advantage\r\nLast login: Wed Sep 13 03:00:23 2017 from 12.345.67.890\r\n\r\n[root@server ~]#\r\n```\r\n\r\n### Create a new user\r\n\r\nThen add a new user to the system which will be used instead of root for login. Replace username in the examples below with a name that you like. After executing the command ```adduser``` you will be asked for new user\u2019s password. Enter a strong password and, optionally, fill in any of the additional information if you would like. This is not required and you can just hit ```ENTER``` in any field you wish to skip.\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"root\" data-host=\"server\"><code class=\" language-bash\">\r\nadduser username\r\n</code></pre>\r\n\r\nNow, we have a new user account with regular account privileges. However, we may sometimes need to do administrative tasks.\r\n\r\nTo avoid having to log out of our normal user and log back in as the root account, we can set up what is known as \"superuser\" or root privileges for our normal account. This will allow our normal user to run commands with administrative privileges by putting the word ```sudo``` before each command.\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"root\" data-host=\"server\"><code class=\" language-bash\">\r\nusermod -aG sudo username\r\n</code></pre>\r\n\r\nNow your user can run commands with superuser privileges! For more information about how this works, check out [this sudoers tutorial](https://www.digitalocean.com/community/tutorials/how-to-edit-the-sudoers-file-on-ubuntu-and-centos).\r\n\r\nTo disable root SSH login, edit ```/etc/ssh/sshd_config``` with your favorite text editor. \r\n\r\nThe most common terminal text editor amongst developers is Vim. It\u2019s a bit complicated but can save you a lot of time. So I provided a few tips for you who didn\u2019t used it before.\r\n\r\nRun the following command (vi is alias for vim):\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"root\" data-host=\"server\"><code class=\" language-bash\">\r\nvi /etc/ssh/sshd_config\r\n</code></pre>\r\n\r\nAs you press enter you will see the Vim text editor. What you should know about Vim is that:\r\n\r\n1. Vim has several modes available. Just keep in mind that there are **command** mode and **other** modes. \r\n2. You can use only **command** and **input** modes to do basic text editing.\r\n3. By default Vim is in **command** mode. To return to command mode from any press ```ESC```. \r\n4. Vim has its commands. Most commands start with colon (```:``` key).\r\n5. To exit Vim run ```:q``` command.\r\n6. To edit a file you should use **input** mode. Press ```i``` key to enter the mode from the command mode. \r\n7. To write to a file use command ```:w```. \r\n8. You can combine commands, i.e., fire ```:wq``` and you will save file on exit.\r\n9. To search for a string hit ```/``` in command mode and then input the string, hit enter.\r\n\r\n#### Vim command reference\r\n\r\nsave: ```:w```\r\nsave and exit: ```:wq```\r\nexit: ```:q```\r\nforce: ```!``` (example ```:w!```, ```:q!```)\r\nvertical split: open a document and then type ```:vsplit /path-to-document/document``` and this will open the specified document and split the screen so you can see both documents.\r\ncopy: ```y```\r\ncopy a line: ```yy```\r\npaste: ```p```\r\ncut: ```d```\r\ncut a line: ```dd```\r\n\r\n[Here](https://www.howtoforge.com/vim-basics) is vim tutorial. You can find a lot of helpful video tutorials on youtube.\r\n\r\nEnter the input mode, edit line and save on exit.\r\n\r\nChange this line:\r\n```language-none\r\n#PermitRootLogin yes\r\n```\r\n\r\nEdit to this:\r\n```language-none\r\nPermitRootLogin no\r\n```\r\n\r\n**Ensure that you are logged into the box with another shell before restarting sshd to avoid locking yourself out of the server.**\r\n\r\n```language-none\r\n[root@server ~]# /etc/init.d/sshd restart\r\nStopping sshd: [ OK ]\r\nStarting sshd: [ OK ]\r\n[root@server ~]#\r\n```\r\n\r\nThat\u2019s it. Now you can logout using ```exit``` command and try to login with new user credentials.\r\n\r\nIf you wish your server be more secured, follow the next step of the tutorial.\r\n\r\n\r\n## Add cryptographic key authentication (recommended)\r\n\r\nIf you already have a key that you want to use, skip to the Copy the Public Key step.\r\n\r\nIf you do not already have an SSH key pair, which consists of a public and private key, you need to generate one. You will need this key to work with such services as [bitbucket](https://bitbucket.org/) or [github](https://github.com). \r\n\r\n\r\n### Generate key pair\r\n\r\nRun this command on your local machine to generate the key pair.\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"user\" data-host=\"localhost\"><code class=\" language-bash\">\r\nssh-keygen\r\n</code></pre>\r\n\r\nYou will be asked few questions after that the key pair will be generated.\r\n\r\n*Note:* you will be asked for a passphrase, which if you provide one will be asked when login to the server. If not, then you won\u2019t have to type the passphrase every time you login.\r\n\r\nThis generates a private key, id_rsa, and a public key, id_rsa.pub, in the .ssh directory of the localuser's home directory. Remember that the private key should not be shared with anyone who should not have access to your servers!\r\n\r\n\r\n### Copy the public key\r\n\r\n#### Option 1: Use ssh-copy-id\r\n\r\nIf your local machine has the ```ssh-copy-id``` script installed, you can use it to install your public key to any user that you have login credentials for.\r\n\r\nRun the ```ssh-copy-id``` script by specifying the user and IP address of the server that you want to install the key on, like this:\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"user\" data-host=\"localhost\"><code class=\" language-bash\">\r\nssh-copy-id username@server\r\n</code></pre>\r\n\r\nAfter providing your password at the prompt, your public key will be added to the remote user's ```.ssh/authorized_keys``` file. The corresponding private key can now be used to log into the server.\r\n\r\n#### Option 2: Manually Install the Key\r\n\r\nAssuming you generated an SSH key pair using the previous step, use the following command at the terminal of your local machine to print your public key (```id_rsa.pub```):\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"user\" data-host=\"localhost\"><code class=\" language-bash\">\r\ncat ~/.ssh/id_rsa.pub\r\n</code></pre>\r\n\r\nThis should print your public SSH key, which should look something like the following:\r\n\r\n```language-none\r\nid_rsa.pub contents\r\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDBGTO0tsVejssuaYR5R3Y/i73SppJAhme1dH7W2c47d4gOqB4izP0+fRLfvbz/tnXFz4iOP/H6eCV05hqUhF+KYRxt9Y8tVMrpDZR2l75o6+xSbUOMu6xN+uVF0T9XzKcxmzTmnV7Na5up3QM3DoSRYX/EP3utr2+zAqpJIfKPLdA74w7g56oYWI9blpnpzxkEd3edVJOivUkpZ4JoenWManvIaSdMTJXMy3MtlQhva+j9CgguyVbUkdzK9KKEuah+pFZvaugtebsU+bllPTB0nlXGIJk98Ie9ZtxuY3nCKneB+KjKiXrAvXUPCI9mWkYS/1rggpFmu3HbXBnWSUdf user@machine.local\r\n```\r\n\r\nSelect the public key, and copy it to your clipboard.\r\n\r\nTo enable the use of SSH key to authenticate as the new remote user, you must add the public key to a special file in the user's home directory.\r\n\r\nOn the **server**, as the **root** user, enter the following command to temporarily switch to the new user (substitute your own user name):\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"root\" data-host=\"server\"><code class=\" language-bash\">\r\nsu - username\r\n</code></pre>\r\n\r\nNow you will be in your new user's home directory.\r\n\r\nCreate a new directory called .ssh and restrict its permissions with the following commands:\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\r\nmkdir ~/.ssh\r\nchmod 700 ~/.ssh\r\n</code></pre>\r\n\r\nNow open a file in ```.ssh``` called ```authorized_keys``` with a text editor. We will use ```vim``` to edit the file:\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\r\nvim ~/.ssh/authorized_keys\r\n</code></pre>\r\n\r\nHit ```i```, insert your public key (which should be in your clipboard) by pasting it into the editor (```CTRL+SHIFT+V```) and save on exit hitting ```ESC```, then ```:wq```.\r\n\r\nNow restrict the permissions of the authorized_keys file with this command:\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\r\nchmod 600 ~/.ssh/authorized_keys\r\n</code></pre>\r\n\r\nType this command **once** to return to the ```root``` user:\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\r\nexit\r\n</code></pre>\r\n\r\nNow your public key is installed, and you can use SSH keys to log in as your user.\r\n\r\n## Disable password authentication\r\n\r\nTo disable password authentication on your server, follow these steps.\r\n\r\nAs root or your new sudo user, open the SSH daemon configuration:\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"root\" data-host=\"server\"><code class=\" language-bash\">\r\nvim /etc/ssh/sshd_config\r\n</code></pre>\r\n\r\nFind the line that specifies PasswordAuthentication, uncomment it by deleting the preceding #, then change its value to \"no\". It should look like this after you have made the change:\r\n\r\n<pre class=\"language-none\"><code class=\" language-none\">\r\nPasswordAuthentication no\r\n</code></pre>\r\n\r\nHere are two other settings that are important for key-only authentication and are set by default. If you haven't modified this file before, you do not need to change these settings:\r\n\r\n<pre class=\"language-none\"><code class=\" language-none\">\r\nPubkeyAuthentication yes\r\nChallengeResponseAuthentication no\r\n</code></pre>\r\n\r\nType this to reload the SSH daemon:\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"root\" data-host=\"server\"><code class=\" language-bash\">\r\nsystemctl reload sshd\r\n</code></pre>\r\n\r\nPassword authentication is now disabled. Your server is now only accessible with SSH key authentication.\r\n\r\n## Set up firewall\r\n\r\nUbuntu 16.04 servers can use the UFW firewall to make sure only connections to certain services are allowed. We can set up a basic firewall very easily using this application.\r\n\r\nDifferent applications can register their profiles with UFW upon installation. These profiles allow UFW to manage these applications by name. OpenSSH, the service allowing us to connect to our server now, has a profile registered with UFW.\r\n\r\nYou can see this by typing:\r\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\r\nsudo ufw app list\r\n</code></pre>\r\n\r\nWe need to make sure that the firewall allows SSH connections so that we can log back in next time. We can allow these connections by typing:\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\r\nsudo ufw allow OpenSSH\r\n</code></pre>\r\n\r\nAfterwards, we can enable the firewall by typing:\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\r\nsudo ufw enable\r\n</code></pre>\r\n\r\nType \"y\" and press ENTER to proceed. You can see that SSH connections are still allowed by typing:\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\r\nsudo ufw status\r\n</code></pre>\r\n\r\nIf you install and configure additional services, you will need to adjust the firewall settings to allow acceptable traffic in. You can learn some common UFW operations in [this guide](https://www.digitalocean.com/community/tutorials/ufw-essentials-common-firewall-rules-and-commands).\r\n\r\n## Set up fail2ban\r\n\r\nA service called fail2ban can mitigate this problem by creating rules that can automatically alter your iptables firewall configuration based on a predefined number of unsuccessful login attempts. This will allow your server to respond to illegitimate access attempts without intervention from you.\r\n\r\n### Install and configure fail2ban\r\n\r\nType the following commands to install fail2ban:\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\r\nsudo apt-get update\r\nsudo apt-get install fail2ban\r\n</code></pre>\r\n\r\nThe fail2ban service keeps its configuration files in the ```/etc/fail2ban``` directory. There is a file with defaults called ```jail.conf```.\r\n\r\nSince this file can be modified by package upgrades, we should not edit this file in-place, but rather copy it so that we can make our changes safely. In order for these two files to operate together successfully, it is best to only include the settings you wish to override in the ```jail.local``` file. All default options will be taken from the ```jail.conf``` file.\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\r\nawk '{ printf \"# \"; print; }' /etc/fail2ban/jail.conf | sudo tee /etc/fail2ban/jail.local\r\n</code></pre>\r\n\r\n\r\nYou will want to evaluate the ```destemail```, ```sendername```, and ```mta``` settings if you wish to configure **email alerts**. The ```destemail``` parameter sets the email address that should receive ban messages. The ```sendername``` sets the value of the \"From\" field in the email. The ```mta``` parameter configures what mail service will be used to send mail. Again, add these to the jail.local file, under the [DEFAULT] header and set to the proper values if you wish to adjust them.\r\n\r\n*Note:* the mail service (```mta```) must be configured properly to send emails. [This tutorial](https://linuxconfig.org/configuring-gmail-as-sendmail-email-relay) can help you configure the ```sendmail``` service. *It is good practice to configure email alerts for most people do not check ```/var/log/auth.log``` file even once a month.*\r\n\r\n<pre class=\"language-none\"><code class=\" language-none\">\r\n[DEFAULT]\r\n. . .\r\naction = $(action_)s\r\n. . .\r\n</code></pre>\r\n\r\nThis parameter configures the action that fail2ban takes when it wants to institute a ban. The value action_ is defined in the file shortly before this parameter. The default action is to simply configure the firewall to reject traffic from the offending host until the ban time elapses.\r\n\r\nIf you would like to configure email alerts, add or uncomment the action item to the jail.local file and change its value from action_ to action_mw. If you want the email to include the relevant log lines, you can change it to action_mwl. Make sure you have the appropriate mail settings configured if you choose to use mail alerts.\r\n\r\nWe're going to configure a auto-banning policy for SSH and Nginx, just as we described above. We want fail2ban to email us when an IP is banned.\r\n\r\nIf you don't already have it, you'll need nginx, since we're going to be monitoring its logs, and you'll need sendmail to mail us notifications. We'll also grab iptables-persistent to allow the server to automatically set up our firewall rules at boot. These can be acquired from Ubuntu's default repositories:\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\r\nsudo apt-get update\r\nsudo apt-get install nginx sendmail iptables-persistent\r\n</code></pre>\r\n\r\nStop the fail2ban service for a moment so that we can establish a base firewall without the rules it adds:\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\r\nsudo service fail2ban stop\r\n</code></pre>\r\n\r\nWhen that is finished, we should implement a default firewall.\r\n\r\nWe're going to tell it to allow established connections, traffic generated by the server itself, traffic destined for our SSH and web server ports. We will drop all other traffic. We can set this basic firewall up by typing:\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\r\nsudo iptables -A INPUT -i lo -j ACCEPT\r\nsudo iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT\r\nsudo iptables -A INPUT -p tcp --dport 22 -j ACCEPT\r\nsudo iptables -A INPUT -p tcp -m multiport --dports 80,443 -j ACCEPT\r\nsudo iptables -A INPUT -j DROP\r\n</code></pre>\r\n\r\nThese commands will implement the above policy. We can see our current firewall rules by typing:\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\r\nsudo iptables -S\r\n</code></pre>\r\n\r\nYou can save the firewalls so that they survive a reboot by typing:\r\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\r\nsudo dpkg-reconfigure iptables-persistent\r\n</code></pre>\r\n\r\nAfterwards, you can restart fail2ban to implement the wrapping rules:\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\r\nsudo service fail2ban start\r\n</code></pre>\r\n\r\nWe can see our current firewall rules by typing:\r\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\r\nsudo iptables -S\r\n</code></pre>\r\n\r\nIf you want to read more on how to set up firewall with fail2ban go [here](https://www.digitalocean.com/community/tutorials/how-to-protect-ssh-with-fail2ban-on-ubuntu-14-04).\r\n\r\nThe next step is optional.\r\n\r\n## Limit your SSH logins using GeoIP (optional)\r\n\r\nAs i mentioned before, you should take some actions to protect the server (primarily, against botnets, which scan almost all available ips and try to break into the server and take control). Most often you will see incoming [bruteforce attacks from Chinese bots](https://www.digitalocean.com/community/questions/is-anyone-else-being-brute-forced-by-chinese-ip-addresses).\r\n\r\n### Install\r\n\r\nInstall GeoIP using the following coman:\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\r\nsudo apt update\r\nsudo apt install geoip-bin geoip-database\r\n</code></pre>\r\n\r\nMake sure it works by doing a simple test:\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\r\n geoiplookup 8.8.8.8\r\n</code></pre>\r\n\r\nCreate the script to filter requests and cut unneeded. \r\nOn ubuntu you can see messages from sshd serrvice in ```/var/log/syslog``` file.\r\n\r\n### Configure\r\n\r\nSave this file in ```/usr/local/bin/sshfilter.sh```:\r\n<pre class=\"language-bash line-numbers\"><code class=\" language-bash line-numbers\">\r\n#!/bin/bash\r\n\r\n# UPPERCASE space-separated country codes to ACCEPT\r\nALLOW_COUNTRIES=\"NZ AU\"\r\n\r\nif [ $# -ne 1 ]; then\r\n  echo \"Usage:  `basename $0` <ip>\" 1>&2\r\n  exit 0 # return true in case of config issue\r\nfi\r\n\r\nCOUNTRY=`/usr/bin/geoiplookup $1 | awk -F \": \" '{ print $2 }' | awk -F \",\" '{ print $1 }' | head -n 1`\r\n\r\n[[ $COUNTRY = \"IP Address not found\" || $ALLOW_COUNTRIES =~ $COUNTRY ]] && RESPONSE=\"ALLOW\" || RESPONSE=\"DENY\"\r\n\r\nif [ $RESPONSE = \"ALLOW\" ]\r\nthen\r\n  exit 0\r\nelse\r\n  logger \"$RESPONSE sshd connection from $1 ($COUNTRY)\"\r\n  exit 1\r\nfi\r\n</code></pre>\r\n\r\nEdit the ALLOW_COUNTRIES to include a list of country codes you want your SSH server to accept connections from. [Here](http://www.nationsonline.org/oneworld/country_code_list.htm) you can find country codes.\r\n\r\nThe last things we need to do is tell the ssh daemon (sshd) to deny all connections (by default) and to run this script to determine whether the connection should be allowed or not.\r\n\r\nIn /etc/hosts.deny add the line:\r\n<pre class=\"language-none\"><code class=\" language-none\">\r\nsshd: ALL\r\n</code></pre>\r\n\r\n\r\nand in /etc/hosts.allow add the line\r\n<pre class=\"language-none\"><code class=\" language-none\">\r\nsshd: ALL: aclexec /usr/local/bin/sshfilter.sh %a\r\n</code></pre>\r\n\r\n### Testing\r\n\r\nObviously you want to test that this is working before you are accidentally logged out of your system. On the console I can do a test with the 8.8.8.8 which I happen to know is from the US, and in my case should be DENIED access. So:\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\r\n/usr/local/bin/sshfilter.sh 8.8.8.8\r\n</code></pre>\r\n\r\n\r\nThe script will not return anything visible, however in /var/log/messages I have the result:\r\n<pre class=\"language-none\"><code class=\" language-none\">\r\nJun 26 17:02:37 pi root: DENY sshd connection from 8.8.8.8 (US)\r\n</code></pre>\r\n\r\n### Updating GeoIP\r\n\r\nIn order to make sure you are up-to-date with your GeoIP (free) country database, you will need to write another script which you can run as a monthly root cron job.\r\n\r\nPlease note that if you just installed the GeoIP database, or you have never manually updated it (it does not auto-update), then you should run the following script manually after installing it! The default database that gets installed is several years old and very inaccurate.\r\n\r\n<pre class=\"language-bash line-numbers\"><code class=\" language-bash line-numbers\">\r\n#!/bin/bash\r\n\r\ncd /tmp\r\nwget -q https://geolite.maxmind.com/download/geoip/database/GeoLiteCountry/GeoIP.dat.gz\r\nif [ -f GeoIP.dat.gz ]\r\nthen\r\n    gzip -d GeoIP.dat.gz\r\n    rm -f /usr/share/GeoIP/GeoIP.dat\r\n    mv -f GeoIP.dat /usr/share/GeoIP/GeoIP.dat\r\nelse\r\n    echo \"The GeoIP library could not be downloaded and updated\"\r\nfi\r\n</code></pre>\r\n\r\n\r\n\r\n## Sources:\r\n\r\n1. [Initial Server Setup with Ubuntu 16.04](https://www.digitalocean.com/community/tutorials/initial-server-setup-with-ubuntu-16-04)\r\n2. [Vim Basics Tutorial](https://www.howtoforge.com/vim-basics)\r\n3. [How To Protect SSH with Fail2Ban on Ubuntu 14.04](https://www.digitalocean.com/community/tutorials/how-to-protect-ssh-with-fail2ban-on-ubuntu-14-04)\r\n4. [Limit your SSH logins using GeoIP](https://www.axllent.org/docs/view/ssh-geoip/)", "minutes_to_read": 15, "created_at": "2017-09-12T13:17:21.066Z", "updated_at": "2017-11-04T12:19:15.094Z", "published_at": "2017-09-12T13:16:40Z", "status": "published"}}, {"model": "post.post", "pk": 2, "fields": {"title": "How to install and setup nginx server, increase page speed, set free ssl certificate [unfinished]", "slug": "how-install-and-setup-nginx-server-increase-page-speed-set-free-ssl-certificate", "excerpt": "This tutorial describes a fast way to setup nginx server, configuring the server for better performance and adding ssl layer (https).", "body": "<h3>Introduction</h3>\n<p>Nginx is one of the most popular web servers in the world and is responsible for hosting some of the largest and highest-traffic sites on the internet. It is more resource-friendly than Apache in most cases and can be used as a web server or a reverse proxy.</p>\n<p>This tutorial describes a fast way to setup nginx server, configuring the server for better performance and adding the ssl layer (https connection).</p>\n<h3>Prerequisites</h3>\n<p>I assume that you already have read my first tutorial, so you know how to login to your server via ssh <strong>not</strong> with<code>root</code>, create and edit files with <code>vim</code> and use root privileges with <code>sudo</code>.</p>\n<h3>Contents</h3>\n<p>This tutorial includes these three parts:</p>\n<ol>\n<li>Setting up nginx with server blocks (essential)</li>\n<li>Configuring nginx for better performance (recommended)</li>\n<li>Adding free SSL cert (https) for your site (optional)</li>\n</ol>\n<p>Let\u2019s start with installing nginx and setting up server blocks.</p>\n<h2>1. Setting up nginx with server blocks (essential)</h2>\n<h3>Install nginx</h3>\n<p>Nginx is available in Ubuntu's default repositories, so the installation is rather straightforward.</p>\n<p>Since this is our first interaction with the <code>apt</code> packaging system in this session, we will update our local package index so that we have access to the most recent package listings. Afterwards, we can install <code>nginx</code>:</p>\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\nsudo apt update\nsudo apt install nginx\n</code></pre>\n\n<h3>Adjust the Firewall</h3>\n<p>Before we can test Nginx, we need to reconfigure our firewall software to allow access to the service. Nginx registers itself as a service with <code>ufw</code>, our firewall, upon installation. This makes it rather easy to allow Nginx access.</p>\n<p>We can list the applications configurations that <code>ufw</code> knows how to work with by typing:</p>\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\nsudo ufw app list\n</code></pre>\n\n<p>You should get a listing of the application profiles:</p>\n<pre><code class=\"language-none\">Available applications:\n  Nginx Full\n  Nginx HTTP\n  Nginx HTTPS\n  OpenSSH\n</code></pre>\n\n<p>As you can see, there are three profiles available for Nginx:</p>\n<pre><code class=\"language-none\">+ **Nginx Full**: This profile opens both port 80 (normal, unencrypted web traffic) and port 443 (TLS/SSL encrypted traffic)\n+ **Nginx HTTP**: This profile opens only port 80 (normal, unencrypted web traffic)\n+ **Nginx HTTPS**: This profile opens only port 443 (TLS/SSL encrypted traffic)\n</code></pre>\n\n<p>It is recommended that you enable the most restrictive profile that will still allow the traffic you've configured. Since we haven't configured SSL for our server yet, in this guide, we will only need to allow traffic on port 80.</p>\n<p>You can enable this by typing:</p>\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\nsudo ufw allow 'Nginx HTTP'\n</code></pre>\n\n<p>You can verify the change by typing:</p>\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\nsudo ufw status\n</code></pre>\n\n<p>You should see HTTP traffic allowed in the displayed output:</p>\n<pre><code class=\"language-none\">Status: active\n\nTo                         Action      From\n--                         ------      ----\nOpenSSH                    ALLOW       Anywhere                  \nNginx HTTP                 ALLOW       Anywhere                  \nOpenSSH (v6)               ALLOW       Anywhere (v6)             \nNginx HTTP (v6)            ALLOW       Anywhere (v6)\n</code></pre>\n\n<h3>Check your Web Server</h3>\n<p>At the end of the installation process, Ubuntu 16.04 starts Nginx. The web server should already be up and running.</p>\n<p>We can check with the <code>systemd</code> init system to make sure the service is running by typing:</p>\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\nsystemctl status nginx\n</code></pre>\n\n<pre><code class=\"language-none\">\u25cf nginx.service - A high performance web server and a reverse proxy server\n   Loaded: loaded (/lib/systemd/system/nginx.service; enabled; vendor preset: enabled)\n   Active: active (running) since Mon 2016-04-18 16:14:00 EDT; 4min 2s ago\n Main PID: 12857 (nginx)\n   CGroup: /system.slice/nginx.service\n           \u251c\u250012857 nginx: master process /usr/sbin/nginx -g daemon on; master_process on\n           \u2514\u250012858 nginx: worker process\n</code></pre>\n\n<p>As you can see above, the service appears to have started successfully. However, the best way to test this is to actually request a page from Nginx.</p>\n<p>You can access the default Nginx landing page to confirm that the software is running properly. You can access this through your server's domain name or IP address.</p>\n<p>If you do not have a domain name set up for your server, you can learn <a href=\"https://digitalocean.com/community/articles/how-to-set-up-a-host-name-with-digitalocean\">how to set up a domain with DigitalOcean</a>.</p>\n<p>If you do not want to set up a domain name for your server, you can use your server's public IP address. If you do not know your server's IP address, you can get it a few different ways from the command line.</p>\n<p>Try typing this at your server's command prompt:</p>\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\nip addr show eth0 | grep inet | awk '{ print $2; }' | sed 's/\\/.*$//'\n</code></pre>\n\n<p>You will get back a few lines. You can try each in your web browser to see if they work.</p>\n<p>When you have your server's IP address or domain, enter it into your browser's address bar:</p>\n<pre><code class=\"language-none\">http://server_domain_or_IP\n</code></pre>\n\n<p>You should see the default Nginx landing page, which should have a heading like: \u201cWelcome to nginx!\u201d.</p>\n<p>This page is simply included with Nginx to show you that the server is running correctly.</p>\n<h3>Manage the Nginx Process</h3>\n<p>Now that you have your web server up and running, we can go over some basic management commands.</p>\n<p>There are several commands which you can use to manage your web server: </p>\n<ol>\n<li><code>start</code> - starts the web server if it\u2019s stopped and config is OK</li>\n<li><code>stop</code> - stops the web server</li>\n<li><code>restart</code> - stops and then starts the web server</li>\n<li><code>reload</code> - reloads configs</li>\n<li><code>enable</code> - sets nginx to start when server boots; nginx is enabled by default</li>\n<li><code>disable</code> - sets nginx not to start at server boot.</li>\n</ol>\n<p>You should use these commands in this way:</p>\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\nsudo systemctl start nginx\n</code></pre>\n\n<p>To test your nginx config before reload use</p>\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\nsudo nginx -t\n</code></pre>\n\n<p>If your server fails to start due to misconfiguration see last lines (command <code>G</code> in <code>vim</code>) of <code>/var/log/nginx/error.log</code> file.</p>\n<h3>Get Familiar with Important Nginx Files and Directories</h3>\n<p>Now that you know how to manage the service itself, you should take a few minutes to familiarize yourself with a few important directories and files.</p>\n<h4>Content</h4>\n<ul>\n<li><code>/var/www/html</code>: The actual web content, which by default only consists of the default Nginx page you saw earlier, is served out of the <code>/var/www/html</code> directory. This can be changed by altering Nginx configuration files.</li>\n</ul>\n<h4>Server Configuration</h4>\n<ul>\n<li>\n<p><code>/etc/nginx</code>: The nginx configuration directory. All of the Nginx configuration files reside here.</p>\n</li>\n<li>\n<p><code>/etc/nginx/nginx.conf</code>: The main Nginx configuration file. This can be modified to make changes to the Nginx global configuration.</p>\n</li>\n<li>\n<p><code>/etc/nginx/sites-available/</code>: The directory where per-site \"server blocks\" can be stored. Nginx will not use the configuration files found in this directory unless they are linked to the <code>sites-enabled</code> directory (see below). Typically, all server block configuration is done in this directory, and then enabled by linking to the other directory.</p>\n</li>\n<li>\n<p><code>/etc/nginx/sites-enabled/</code>: The directory where enabled per-site \"server blocks\" are stored. Typically, these are created by linking to configuration files found in the <code>sites-available</code> directory.</p>\n</li>\n<li>\n<p><code>/etc/nginx/snippets</code>: This directory contains configuration fragments that can be included elsewhere in the Nginx configuration. Potentially repeatable configuration segments are good candidates for refactoring into snippets.</p>\n</li>\n</ul>\n<h4>Server Logs</h4>\n<ul>\n<li><code>/var/log/nginx/access.log</code>: Every request to your web server is recorded in this log file unless Nginx is configured to do otherwise.</li>\n<li><code>/var/log/nginx/error.log</code>: Any Nginx errors will be recorded in this log.</li>\n</ul>\n<h3>Set Up Nginx Server Blocks (Virtual Hosts)</h3>\n<p>When using the Nginx web server, server blocks (similar to the virtual hosts in Apache) can be used to encapsulate configuration details and host more than one domain off of a single server.</p>\n<h4>Example Configuration</h4>\n<p>For demonstration purposes, we're going to set up two domains with our Nginx server. The domain names we'll use in this guide are <strong>example.com</strong> and <strong>test.com</strong>.</p>\n<h4>Set Up New Document Root Directories</h4>\n<p>By default, Nginx on Ubuntu 16.04 has one server block enabled by default. It is configured to serve documents out of a directory at <code>/var/www/html</code>.</p>\n<p>We will create a directory structure within <code>/var/www</code> for each of our sites. The actual web content will be placed in an <code>html</code> directory within these site-specific directories. This gives us some additional flexibility to create other directories associated with our sites as siblings to the <code>html</code> directory if necessary.</p>\n<p>We need to create these directories for each of our sites. The <code>-p</code> flag tells mkdir to create any necessary parent directories along the way:</p>\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\nsudo mkdir -p /var/www/example.com/html\nsudo mkdir -p /var/www/test.com/html\n</code></pre>\n\n<p>Now that we have our directories, we will reassign ownership of the web directories to our normal user account. This will let us write to them without <code>sudo</code>.</p>\n<p><em>Note:</em> Depending on your needs, you might need to adjust the permissions or ownership of the folders again to allow certain access to the <strong>www-data</strong> user. For instance, dynamic sites will often need this. The specific permissions and ownership requirements entirely depend on what your configuration. Follow the recommendations for the specific technology you're using.</p>\n<p>We can use the <code>$USER</code> environmental variable to assign ownership to the account that we are currently signed in on (make sure you're not logged in as <code>root</code>). This will allow us to easily create or edit the content in this directory:</p>\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\nsudo chown -R $USER:www-data /var/www/example.com/html\nsudo chown -R $USER:www-data /var/www/test.com/html\n</code></pre>\n\n<p>The permissions of our web roots should be correct already if you have not modified your <code>umask</code> value, but we can make sure by typing:</p>\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\nsudo chmod -R 755 /var/www\n</code></pre>\n\n<p>Our directory structure is now configured and we can move on.</p>\n<h4>Create Sample Pages for Each Site</h4>\n<p>Now that we have our directory structure set up, let's create a default page for each of our sites so that we will have something to display.</p>\n<p>Create an <code>index.html</code> file in your first domain:</p>\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\nvim  /var/www/example.com/html/index.html\n</code></pre>\n\n<p>Inside the file, we'll create a really basic file that indicates what site we are currently accessing. It will look like this:</p>\n<pre><code class=\"language-html\">&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;Welcome to Example.com!&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;h1&gt;Success!  The example.com server block is working!&lt;/h1&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n\n<p>Since the file for our second site is basically going to be the same, we can copy it over to our second document root like this:</p>\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\ncp /var/www/example.com/html/index.html /var/www/test.com/html/\n</code></pre>\n\n<p>Modify it so that it refers to our second domain:</p>\n<pre><code class=\"language-html\">&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;Welcome to Test.com!&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;h1&gt;Success!  The test.com server block is working!&lt;/h1&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n\n<h4>Create Server Block Files for Each Domain</h4>\n<p>Now that we have the content we wish to serve, we need to actually create the server blocks that will tell Nginx how to do this.</p>\n<p>By default, Nginx contains one server block called <code>default</code> which we can use as a template for our own configurations. We will begin by designing our first domain's server block, which we will then copy over for our second domain and make the necessary modifications.</p>\n<h5>Create the First Server Block File</h5>\n<p>Copy and open the new file you created in your text editor with <code>sudo</code> privileges</p>\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\nsudo cp /etc/nginx/sites-available/default /etc/nginx/sites-available/example.com\nsudo vim /etc/nginx/sites-available/example.com\n</code></pre>\n\n<p>Ignoring the commented lines, the file will look similar to this:</p>\n<pre><code class=\"language-none\">server {\n        listen 80 default_server;\n        listen [::]:80 default_server;\n\n        root /var/www/html;\n        index index.html index.htm index.nginx-debian.html;\n\n        server_name _;\n\n        location / {\n                try_files $uri $uri/ =404;\n        }\n}\n</code></pre>\n\n<p>First, we need to look at the listen directives. <strong>Only one of our server blocks on the server can have the <code>default_server</code> option enabled.</strong> This specifies which block should serve a request if the <code>server_name</code> requested does not match any of the available server blocks. This shouldn't happen very frequently in real world scenarios since visitors will be accessing your site through your domain name.</p>\n<p>You can choose to designate one of your sites as the \"default\" by including the <code>default_server</code> option in the <code>listen</code> directive, or you can leave the default server block enabled, which will serve the content of the <code>/var/www/html directory</code> if the requested host cannot be found.</p>\n<p>In this guide, we'll leave the default server block in place to server non-matching requests, so we'll remove the <code>default_server</code> from this and the next server block. You can choose to add the option to whichever of your server blocks makes sense to you.</p>\n<pre><code class=\"language-none\">server {\n        listen 80;\n        listen [::]:80;\n\n        . . .\n}\n</code></pre>\n\n<p><em>Note:</em> You can check that the default_server option is only enabled in a single active file by typing:</p>\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\ngrep -R default_server /etc/nginx/sites-enabled/\n</code></pre>\n\n<p>If matches are found uncommented in more than one file (shown in the leftmost column), Nginx will complain about an invalid configuration.</p>\n<p>The next thing we're going to have to adjust is the document <code>root</code>, specified by the root directive. Point it to the site's document root that you created:</p>\n<pre><code class=\"language-none\">server {\n        listen 80;\n        listen [::]:80;\n\n        root /var/www/example.com/html;\n\n}\n</code></pre>\n\n<p>Next, we need to modify the <code>server_name</code> to match requests for our first domain. We can additionally add any aliases that we want to match. We will add a <code>www.example.com</code> alias to demonstrate.</p>\n<p>When you are finished, your file will look something like this:</p>\n<pre><code class=\"language-none\">server {\n        listen 80;\n        listen [::]:80;\n\n        root /var/www/example.com/html;\n        index index.html index.htm index.nginx-debian.html;\n\n        server_name example.com www.example.com;\n\n        location / {\n                try_files $uri $uri/ =404;\n        }\n}\n</code></pre>\n\n<p>That is all we need for a basic configuration. Save and close the file to exit.</p>\n<h5>Create the Second Server Block File</h5>\n<p>Now that we have our initial server block configuration, we can use that as a basis for our second file. Copy it over to create a new file and open for editing:</p>\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\nsudo cp /etc/nginx/sites-available/default /etc/nginx/sites-available/example.com\nsudo vim /etc/nginx/sites-available/example.com\n</code></pre>\n\n<p>Again, make sure that you do not use the <code>default_server</code> option for the <code>listen</code> directive in this file if you've already used it elsewhere. Adjust the <code>root</code> directive to point to your second domain's document root and adjust the <code>server_name</code> to match your second site's domain name (make sure to include any aliases).</p>\n<p>When you are finished, your file will likely look something like this:</p>\n<pre><code class=\"language-none\">server {\n        listen 80;\n        listen [::]:80;\n\n        root /var/www/test.com/html;\n        index index.html index.htm index.nginx-debian.html;\n\n        server_name test.com www.test.com;\n\n        location / {\n                try_files $uri $uri/ =404;\n        }\n}\n</code></pre>\n\n<h5>Enable your Server Blocks and Restart Nginx</h5>\n<p>Now that we have our server block files, we need to enable them. We can do this by creating symbolic links from these files to the sites-enabled directory, which Nginx reads from during startup.</p>\n<p>We can create these links by typing:</p>\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\nsudo ln -s /etc/nginx/sites-available/example.com /etc/nginx/sites-enabled/\nsudo ln -s /etc/nginx/sites-available/test.com /etc/nginx/sites-enabled/\n</code></pre>\n\n<p>These files are now in the enabled directory. We now have three server blocks enabled, which are configured to respond based on their <code>listen</code> directive and the <code>server_name</code> (you can read more about how Nginx processes these directives <a href=\"https://www.digitalocean.com/community/tutorials/understanding-nginx-server-and-location-block-selection-algorithms\">here</a>):<br />\n+ <code>example.com</code>: Will respond to requests for <code>example.com</code> and <code>www.example.com</code><br />\n+ <code>test.com</code>: Will respond to requests for <code>test.com</code> and <code>www.test.com</code><br />\n+ <code>default</code>: Will respond to any requests on port 80 that do not match the other two blocks.</p>\n<p>In order to avoid a possible hash bucket memory problem that can arise from adding additional server names, we will go ahead and adjust a single value within our <code>/etc/nginx/nginx.conf</code> file. Open the file now:</p>\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\nsudo vim /etc/nginx/nginx.conf\n</code></pre>\n\n<p>Within the file, find the <code>server_names_hash_bucket_size</code> directive. Remove the <code>#</code> symbol to uncomment the line:</p>\n<pre><code class=\"language-none\">http {\n    . . .\n\n    server_names_hash_bucket_size 64;\n\n    . . .\n}\n</code></pre>\n\n<p>Next, test to make sure that there are no syntax errors in any of your Nginx files:</p>\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\nsudo nginx -t\n</code></pre>\n\n<p>If no problems were found, restart Nginx to enable your changes:</p>\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\nsudo systemctl restart nginx\n</code></pre>\n\n<p>Nginx should now be serving both of your domain names.</p>\n<h5>Modify Your Local Hosts File for Testing (Optional)</h5>\n<p>If you have not been using domain names that you own and instead have been using dummy values, you can modify your local computer's configuration to let you to temporarily test your Nginx server block configuration.</p>\n<p>This will not allow other visitors to view your site correctly, but it will give you the ability to reach each site independently and test your configuration. This basically works by intercepting requests that would usually go to DNS to resolve domain names. Instead, we can set the IP addresses we want our local computer to go to when we request the domain names.</p>\n<h1>to be continued...</h1>", "markdown": "### Introduction\r\n\r\nNginx is one of the most popular web servers in the world and is responsible for hosting some of the largest and highest-traffic sites on the internet. It is more resource-friendly than Apache in most cases and can be used as a web server or a reverse proxy.\r\n\r\nThis tutorial describes a fast way to setup nginx server, configuring the server for better performance and adding the ssl layer (https connection).\r\n\r\n### Prerequisites\r\n\r\nI assume that you already have read my first tutorial, so you know how to login to your server via ssh **not** with```root```, create and edit files with ```vim``` and use root privileges with ```sudo```.\r\n\r\n### Contents\r\n\r\nThis tutorial includes these three parts:\r\n\r\n1. Setting up nginx with server blocks (essential)\r\n2. Configuring nginx for better performance (recommended)\r\n3. Adding free SSL cert (https) for your site (optional)\r\n\r\nLet\u2019s start with installing nginx and setting up server blocks.\r\n\r\n## 1. Setting up nginx with server blocks (essential)\r\n\r\n### Install nginx\r\n\r\nNginx is available in Ubuntu's default repositories, so the installation is rather straightforward.\r\n\r\nSince this is our first interaction with the ```apt``` packaging system in this session, we will update our local package index so that we have access to the most recent package listings. Afterwards, we can install ```nginx```:\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\r\nsudo apt update\r\nsudo apt install nginx\r\n</code></pre>\r\n\r\n### Adjust the Firewall\r\n\r\nBefore we can test Nginx, we need to reconfigure our firewall software to allow access to the service. Nginx registers itself as a service with ```ufw```, our firewall, upon installation. This makes it rather easy to allow Nginx access.\r\n\r\nWe can list the applications configurations that ```ufw``` knows how to work with by typing:\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\r\nsudo ufw app list\r\n</code></pre>\r\n\r\nYou should get a listing of the application profiles:\r\n\r\n```language-none\r\nAvailable applications:\r\n  Nginx Full\r\n  Nginx HTTP\r\n  Nginx HTTPS\r\n  OpenSSH\r\n```\r\n\r\nAs you can see, there are three profiles available for Nginx:\r\n\r\n```language-none\r\n+ **Nginx Full**: This profile opens both port 80 (normal, unencrypted web traffic) and port 443 (TLS/SSL encrypted traffic)\r\n+ **Nginx HTTP**: This profile opens only port 80 (normal, unencrypted web traffic)\r\n+ **Nginx HTTPS**: This profile opens only port 443 (TLS/SSL encrypted traffic)\r\n```\r\n\r\nIt is recommended that you enable the most restrictive profile that will still allow the traffic you've configured. Since we haven't configured SSL for our server yet, in this guide, we will only need to allow traffic on port 80.\r\n\r\nYou can enable this by typing:\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\r\nsudo ufw allow 'Nginx HTTP'\r\n</code></pre>\r\n\r\nYou can verify the change by typing:\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\r\nsudo ufw status\r\n</code></pre>\r\n\r\nYou should see HTTP traffic allowed in the displayed output:\r\n\r\n```language-none\r\nStatus: active\r\n\r\nTo                         Action      From\r\n--                         ------      ----\r\nOpenSSH                    ALLOW       Anywhere                  \r\nNginx HTTP                 ALLOW       Anywhere                  \r\nOpenSSH (v6)               ALLOW       Anywhere (v6)             \r\nNginx HTTP (v6)            ALLOW       Anywhere (v6)\r\n```\r\n\r\n### Check your Web Server\r\n\r\nAt the end of the installation process, Ubuntu 16.04 starts Nginx. The web server should already be up and running.\r\n\r\nWe can check with the ```systemd``` init system to make sure the service is running by typing:\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\r\nsystemctl status nginx\r\n</code></pre>\r\n\r\n```language-none\r\n\u25cf nginx.service - A high performance web server and a reverse proxy server\r\n   Loaded: loaded (/lib/systemd/system/nginx.service; enabled; vendor preset: enabled)\r\n   Active: active (running) since Mon 2016-04-18 16:14:00 EDT; 4min 2s ago\r\n Main PID: 12857 (nginx)\r\n   CGroup: /system.slice/nginx.service\r\n           \u251c\u250012857 nginx: master process /usr/sbin/nginx -g daemon on; master_process on\r\n           \u2514\u250012858 nginx: worker process\r\n```\r\n\r\nAs you can see above, the service appears to have started successfully. However, the best way to test this is to actually request a page from Nginx.\r\n\r\nYou can access the default Nginx landing page to confirm that the software is running properly. You can access this through your server's domain name or IP address.\r\n\r\nIf you do not have a domain name set up for your server, you can learn [how to set up a domain with DigitalOcean](https://digitalocean.com/community/articles/how-to-set-up-a-host-name-with-digitalocean).\r\n\r\nIf you do not want to set up a domain name for your server, you can use your server's public IP address. If you do not know your server's IP address, you can get it a few different ways from the command line.\r\n\r\nTry typing this at your server's command prompt:\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\r\nip addr show eth0 | grep inet | awk '{ print $2; }' | sed 's/\\/.*$//'\r\n</code></pre>\r\n\r\nYou will get back a few lines. You can try each in your web browser to see if they work.\r\n\r\nWhen you have your server's IP address or domain, enter it into your browser's address bar:\r\n\r\n```language-none\r\nhttp://server_domain_or_IP\r\n```\r\n\r\nYou should see the default Nginx landing page, which should have a heading like: \u201cWelcome to nginx!\u201d.\r\n\r\nThis page is simply included with Nginx to show you that the server is running correctly.\r\n\r\n### Manage the Nginx Process\r\n\r\nNow that you have your web server up and running, we can go over some basic management commands.\r\n\r\nThere are several commands which you can use to manage your web server: \r\n\r\n1. ```start``` - starts the web server if it\u2019s stopped and config is OK\r\n2.  ```stop``` - stops the web server\r\n3. ```restart``` - stops and then starts the web server\r\n4. ```reload``` - reloads configs\r\n5. ```enable``` - sets nginx to start when server boots; nginx is enabled by default\r\n6. ```disable``` - sets nginx not to start at server boot.\r\n\r\nYou should use these commands in this way:\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\r\nsudo systemctl start nginx\r\n</code></pre>\r\n\r\nTo test your nginx config before reload use\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\r\nsudo nginx -t\r\n</code></pre>\r\n\r\nIf your server fails to start due to misconfiguration see last lines (command ```G``` in ```vim```) of ```/var/log/nginx/error.log``` file.\r\n\r\n### Get Familiar with Important Nginx Files and Directories\r\n\r\nNow that you know how to manage the service itself, you should take a few minutes to familiarize yourself with a few important directories and files.\r\n\r\n#### Content\r\n\r\n+ ```/var/www/html```: The actual web content, which by default only consists of the default Nginx page you saw earlier, is served out of the ```/var/www/html``` directory. This can be changed by altering Nginx configuration files.\r\n\r\n#### Server Configuration\r\n\r\n+ ```/etc/nginx```: The nginx configuration directory. All of the Nginx configuration files reside here.\r\n\r\n+ ```/etc/nginx/nginx.conf```: The main Nginx configuration file. This can be modified to make changes to the Nginx global configuration.\r\n\r\n+ ```/etc/nginx/sites-available/```: The directory where per-site \"server blocks\" can be stored. Nginx will not use the configuration files found in this directory unless they are linked to the ```sites-enabled``` directory (see below). Typically, all server block configuration is done in this directory, and then enabled by linking to the other directory.\r\n\r\n+ ```/etc/nginx/sites-enabled/```: The directory where enabled per-site \"server blocks\" are stored. Typically, these are created by linking to configuration files found in the ```sites-available``` directory.\r\n\r\n+ ```/etc/nginx/snippets```: This directory contains configuration fragments that can be included elsewhere in the Nginx configuration. Potentially repeatable configuration segments are good candidates for refactoring into snippets.\r\n\r\n#### Server Logs\r\n\r\n+ ```/var/log/nginx/access.log```: Every request to your web server is recorded in this log file unless Nginx is configured to do otherwise.\r\n+ ```/var/log/nginx/error.log```: Any Nginx errors will be recorded in this log.\r\n\r\n### Set Up Nginx Server Blocks (Virtual Hosts)\r\n\r\nWhen using the Nginx web server, server blocks (similar to the virtual hosts in Apache) can be used to encapsulate configuration details and host more than one domain off of a single server.\r\n\r\n#### Example Configuration\r\n\r\nFor demonstration purposes, we're going to set up two domains with our Nginx server. The domain names we'll use in this guide are **example.com** and **test.com**.\r\n\r\n#### Set Up New Document Root Directories\r\n\r\nBy default, Nginx on Ubuntu 16.04 has one server block enabled by default. It is configured to serve documents out of a directory at ```/var/www/html```.\r\n\r\nWe will create a directory structure within ```/var/www``` for each of our sites. The actual web content will be placed in an ```html``` directory within these site-specific directories. This gives us some additional flexibility to create other directories associated with our sites as siblings to the ```html``` directory if necessary.\r\n\r\nWe need to create these directories for each of our sites. The ```-p``` flag tells mkdir to create any necessary parent directories along the way:\r\n\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\r\nsudo mkdir -p /var/www/example.com/html\r\nsudo mkdir -p /var/www/test.com/html\r\n</code></pre>\r\n\r\nNow that we have our directories, we will reassign ownership of the web directories to our normal user account. This will let us write to them without ```sudo```.\r\n\r\n*Note:* Depending on your needs, you might need to adjust the permissions or ownership of the folders again to allow certain access to the **www-data** user. For instance, dynamic sites will often need this. The specific permissions and ownership requirements entirely depend on what your configuration. Follow the recommendations for the specific technology you're using.\r\n\r\nWe can use the ```$USER``` environmental variable to assign ownership to the account that we are currently signed in on (make sure you're not logged in as ```root```). This will allow us to easily create or edit the content in this directory:\r\n\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\r\nsudo chown -R $USER:www-data /var/www/example.com/html\r\nsudo chown -R $USER:www-data /var/www/test.com/html\r\n</code></pre>\r\n\r\nThe permissions of our web roots should be correct already if you have not modified your ```umask``` value, but we can make sure by typing:\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\r\nsudo chmod -R 755 /var/www\r\n</code></pre>\r\n\r\nOur directory structure is now configured and we can move on.\r\n\r\n#### Create Sample Pages for Each Site\r\n\r\nNow that we have our directory structure set up, let's create a default page for each of our sites so that we will have something to display.\r\n\r\nCreate an ```index.html``` file in your first domain:\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\r\nvim  /var/www/example.com/html/index.html\r\n</code></pre>\r\n\r\nInside the file, we'll create a really basic file that indicates what site we are currently accessing. It will look like this:\r\n\r\n```language-html\r\n<html>\r\n    <head>\r\n        <title>Welcome to Example.com!</title>\r\n    </head>\r\n    <body>\r\n        <h1>Success!  The example.com server block is working!</h1>\r\n    </body>\r\n</html>\r\n```\r\nSince the file for our second site is basically going to be the same, we can copy it over to our second document root like this:\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\r\ncp /var/www/example.com/html/index.html /var/www/test.com/html/\r\n</code></pre>\r\n\r\nModify it so that it refers to our second domain:\r\n\r\n```language-html\r\n<html>\r\n    <head>\r\n        <title>Welcome to Test.com!</title>\r\n    </head>\r\n    <body>\r\n        <h1>Success!  The test.com server block is working!</h1>\r\n    </body>\r\n</html>\r\n```\r\n\r\n#### Create Server Block Files for Each Domain\r\n\r\nNow that we have the content we wish to serve, we need to actually create the server blocks that will tell Nginx how to do this.\r\n\r\nBy default, Nginx contains one server block called ```default``` which we can use as a template for our own configurations. We will begin by designing our first domain's server block, which we will then copy over for our second domain and make the necessary modifications.\r\n\r\n##### Create the First Server Block File\r\n\r\nCopy and open the new file you created in your text editor with ```sudo``` privileges\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\r\nsudo cp /etc/nginx/sites-available/default /etc/nginx/sites-available/example.com\r\nsudo vim /etc/nginx/sites-available/example.com\r\n</code></pre>\r\n\r\n\r\nIgnoring the commented lines, the file will look similar to this:\r\n\r\n```language-none\r\nserver {\r\n        listen 80 default_server;\r\n        listen [::]:80 default_server;\r\n\r\n        root /var/www/html;\r\n        index index.html index.htm index.nginx-debian.html;\r\n\r\n        server_name _;\r\n\r\n        location / {\r\n                try_files $uri $uri/ =404;\r\n        }\r\n}\r\n```\r\n\r\nFirst, we need to look at the listen directives. **Only one of our server blocks on the server can have the ```default_server``` option enabled.** This specifies which block should serve a request if the ```server_name``` requested does not match any of the available server blocks. This shouldn't happen very frequently in real world scenarios since visitors will be accessing your site through your domain name.\r\n\r\nYou can choose to designate one of your sites as the \"default\" by including the ```default_server``` option in the ```listen``` directive, or you can leave the default server block enabled, which will serve the content of the ```/var/www/html directory``` if the requested host cannot be found.\r\n\r\nIn this guide, we'll leave the default server block in place to server non-matching requests, so we'll remove the ```default_server``` from this and the next server block. You can choose to add the option to whichever of your server blocks makes sense to you.\r\n\r\n```language-none\r\nserver {\r\n        listen 80;\r\n        listen [::]:80;\r\n\r\n        . . .\r\n}\r\n```\r\n\r\n*Note:* You can check that the default_server option is only enabled in a single active file by typing:\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\r\ngrep -R default_server /etc/nginx/sites-enabled/\r\n</code></pre>\r\n\r\nIf matches are found uncommented in more than one file (shown in the leftmost column), Nginx will complain about an invalid configuration.\r\n\r\nThe next thing we're going to have to adjust is the document ```root```, specified by the root directive. Point it to the site's document root that you created:\r\n\r\n```language-none\r\nserver {\r\n        listen 80;\r\n        listen [::]:80;\r\n\r\n        root /var/www/example.com/html;\r\n\r\n}\r\n```\r\n\r\nNext, we need to modify the ```server_name``` to match requests for our first domain. We can additionally add any aliases that we want to match. We will add a ```www.example.com``` alias to demonstrate.\r\n\r\nWhen you are finished, your file will look something like this:\r\n\r\n```language-none\r\nserver {\r\n        listen 80;\r\n        listen [::]:80;\r\n\r\n        root /var/www/example.com/html;\r\n        index index.html index.htm index.nginx-debian.html;\r\n\r\n        server_name example.com www.example.com;\r\n\r\n        location / {\r\n                try_files $uri $uri/ =404;\r\n        }\r\n}\r\n```\r\n\r\nThat is all we need for a basic configuration. Save and close the file to exit.\r\n\r\n##### Create the Second Server Block File\r\n\r\nNow that we have our initial server block configuration, we can use that as a basis for our second file. Copy it over to create a new file and open for editing:\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\r\nsudo cp /etc/nginx/sites-available/default /etc/nginx/sites-available/example.com\r\nsudo vim /etc/nginx/sites-available/example.com\r\n</code></pre>\r\n\r\nAgain, make sure that you do not use the ```default_server``` option for the ```listen``` directive in this file if you've already used it elsewhere. Adjust the ```root``` directive to point to your second domain's document root and adjust the ```server_name``` to match your second site's domain name (make sure to include any aliases).\r\n\r\nWhen you are finished, your file will likely look something like this:\r\n\r\n```language-none\r\nserver {\r\n        listen 80;\r\n        listen [::]:80;\r\n\r\n        root /var/www/test.com/html;\r\n        index index.html index.htm index.nginx-debian.html;\r\n\r\n        server_name test.com www.test.com;\r\n\r\n        location / {\r\n                try_files $uri $uri/ =404;\r\n        }\r\n}\r\n```\r\n\r\n##### Enable your Server Blocks and Restart Nginx\r\n\r\nNow that we have our server block files, we need to enable them. We can do this by creating symbolic links from these files to the sites-enabled directory, which Nginx reads from during startup.\r\n\r\nWe can create these links by typing:\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\r\nsudo ln -s /etc/nginx/sites-available/example.com /etc/nginx/sites-enabled/\r\nsudo ln -s /etc/nginx/sites-available/test.com /etc/nginx/sites-enabled/\r\n</code></pre>\r\n\r\nThese files are now in the enabled directory. We now have three server blocks enabled, which are configured to respond based on their ```listen``` directive and the ```server_name``` (you can read more about how Nginx processes these directives [here](https://www.digitalocean.com/community/tutorials/understanding-nginx-server-and-location-block-selection-algorithms)):\r\n+ ```example.com```: Will respond to requests for ```example.com``` and ```www.example.com```\r\n+ ```test.com```: Will respond to requests for ```test.com``` and ```www.test.com```\r\n+ ```default```: Will respond to any requests on port 80 that do not match the other two blocks.\r\n\r\nIn order to avoid a possible hash bucket memory problem that can arise from adding additional server names, we will go ahead and adjust a single value within our ```/etc/nginx/nginx.conf``` file. Open the file now:\r\n\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\r\nsudo vim /etc/nginx/nginx.conf\r\n</code></pre>\r\n\r\nWithin the file, find the ```server_names_hash_bucket_size``` directive. Remove the ```# ``` symbol to uncomment the line:\r\n\r\n```language-none\r\nhttp {\r\n    . . .\r\n\r\n    server_names_hash_bucket_size 64;\r\n\r\n    . . .\r\n}\r\n```\r\n\r\nNext, test to make sure that there are no syntax errors in any of your Nginx files:\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\r\nsudo nginx -t\r\n</code></pre>\r\n\r\nIf no problems were found, restart Nginx to enable your changes:\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"username\" data-host=\"server\"><code class=\" language-bash\">\r\nsudo systemctl restart nginx\r\n</code></pre>\r\n\r\nNginx should now be serving both of your domain names.\r\n\r\n##### Modify Your Local Hosts File for Testing (Optional)\r\n\r\nIf you have not been using domain names that you own and instead have been using dummy values, you can modify your local computer's configuration to let you to temporarily test your Nginx server block configuration.\r\n\r\nThis will not allow other visitors to view your site correctly, but it will give you the ability to reach each site independently and test your configuration. This basically works by intercepting requests that would usually go to DNS to resolve domain names. Instead, we can set the IP addresses we want our local computer to go to when we request the domain names.\r\n\r\n\r\n# to be continued...", "minutes_to_read": 25, "created_at": "2017-10-30T15:25:14.909Z", "updated_at": "2017-11-30T00:55:45.125Z", "published_at": "2017-10-30T15:23:59Z", "status": "published"}}, {"model": "post.post", "pk": 3, "fields": {"title": "How to setup celery with django using redis as a message broker", "slug": "how-setup-celery-django-using-redis-message-broker", "excerpt": "This tutorial describes how to setup celery tasks scheduler for django app with django\u2019s admin interface for the purpose (tasks scheduling).", "body": "<p>This tutorial describes how to setup celery tasks scheduler for django app with django\u2019s admin interface for the purpose (tasks scheduling).</p>\n<p>This tutorial consists of 3 parts: installation, configuration and instructions what to do next.</p>\n<h2>Installation</h2>\n<p>Run the following commands in your venv:<br />\n<pre class=\"command-line language-bash\" data-user=\"(env) user\" data-host=\"server\"><code class=\" language-bash\"><br />\npip install -U \"celery[redis]\"<br />\npip install django-celery-beat<br />\npip install django-celery-result<br />\n</code></pre></p>\n<h2>Configuration</h2>\n<p>Let\u2019s create script with configs for celery. We have similar to the following project structure at the moment of writing this tutorial.</p>\n<pre><code class=\"language-bash\">...\nmanage.py\napps\nbase\n- tasks\n- - task01.py\n- - task02.py\n- celeryconf.py\n...\n</code></pre>\n\n<p><strong>celeryconf.py</strong></p>\n<pre class=\"language-python line-numbers\"><code class=\" language-python line-numbers\">\nimport os\nfrom celery import Celery\nfrom kombu import Queue, Exchange\napp = Celery('tasks')\ndefault_exchange = Exchange('default', type='direct')\napp.conf.task_queues = (\n    Queue('default', default_exchange, routing_key='default'),\n)\napp.conf.task_default_queue = 'default'\napp.conf.task_default_exchange = 'default'\napp.conf.task_default_exchange_type = 'direct'\napp.conf.task_default_routing_key = 'default'\napp.conf.task_queues = (\n    Queue('default', default_exchange, routing_key='default'),\n)\napp.conf.beat_scheduler = 'django_celery_beat.schedulers:DatabaseScheduler'\nos.environ.setdefault('DJANGO_SETTINGS_MODULE', 'base.settings')\napp.config_from_object('django.conf:settings', namespace='CELERY')\napp.autodiscover_tasks()\n# hack for celery beat\nimport django\ndjango.setup()\n</code></pre>\n\n<p><strong>tasks/<strong>init</strong>.py</strong><br />\n<pre class=\"language-python line-numbers\"><code class=\" language-python line-numbers\"><br />\nfrom celery import shared_task<br />\nfrom celery.utils.log import get_task_logger<br />\nlogger = get_task_logger(<strong>name</strong>)</p>\n<p>@shared_task<br />\ndef parse_admitad_yml(channel_id=56):</p>\n<pre><code>from .parse_admitad_yml import ParseAdmitadYml\n\nlogger.info('Running parse_admitad_yml for channel_id %s', channel_id)\nparser = ParseAdmitadYml()\ntry:\n    parser.execute(channel_id)\nexcept Exception:\n    return 1\n\nreturn 0\n</code></pre>\n<p>@shared_task<br />\ndef create_things():</p>\n<pre><code>from .create_things import CreateThings\n\nlogger.info('Running create_things')\n\ntry:\n    create_things = CreateThings()\n    create_things.execute()\nexcept Exception:\n    return 1\n\nreturn 0\n</code></pre>\n<p>@shared_task<br />\ndef create_things_auto():<br />\n    from .create_things_auto import CreateThingsAuto</p>\n<pre><code>logger.info('Running create_things_auto')\n\ntry:\n    create_things_auto = CreateThingsAuto()\n    create_things_auto.execute()\nexcept Exception:\n    return 1\n\nreturn 0\n</code></pre>\n<p>@shared_task<br />\ndef add_pictures_to_things():<br />\n    from .add_pictures_to_things import AddPicturesToThings</p>\n<pre><code>logger.info('Running add_pictures_to_things')\n\ntry:\n    add_pictures_to_things = AddPicturesToThings()\n    add_pictures_to_things.execute()\nexcept Exception:\n    return 1\n\nreturn 0\n</code></pre>\n<p></code></pre></p>\n<p><strong>tasks/task01.py</strong><br />\n<pre class=\"language-python line-numbers\"><code class=\" language-python line-numbers\"><br />\n# coding: utf-8<br />\nfrom django.core.management.base import NoArgsCommand<br />\nfrom django.utils.translation import activate<br />\nfrom admitad.models import Thing</p>\n<p>class CreateThings:<br />\n    \"\"\"A class for a celery task\"\"\"<br />\n    def execute():<br />\n        Thing.create_shop_things()<br />\n</code></pre></p>\n<p>Start redis server with<br />\n<pre class=\"command-line language-bash\" data-user=\"user\" data-host=\"server\"><code class=\" language-bash\"><br />\nredis-server<br />\n</code></pre></p>\n<p>Start a celery worker (executes the tasks) with the command:<br />\n<pre class=\"command-line language-bash\" data-user=\"(env) user\" data-host=\"server\"><code class=\" language-bash\"><br />\ncelery -A base.celeryconf worker -l info<br />\n</code></pre></p>\n<p>Then start a celery beat (adds tasks to the celery  queue) with the command:<br />\n<pre class=\"command-line language-bash\" data-user=\"(env) user\" data-host=\"server\"><code class=\" language-bash\"><br />\ncelery -A base.celeryconf beat -l info<br />\n</code></pre></p>\n<h3>The final words</h3>\n<p>If you completed the steps described above, you must have the celery setup for your django application up and running. All that lasts is to daemonize things. You should run the redis server, celery worker and beat in daemon mode (as background processes) for the task scheduling system to work using django admin interface. For more info on the subject see celery docs.</p>\n<h2>Sources:</h2>\n<ol>\n<li><a href=\"http://docs.celeryproject.org/en/latest/index.html\">Celery 4.1.0 documentation</a></li>\n<li><a href=\"https://www.codingforentrepreneurs.com/blog/celery-redis-django/\">Celery + Redis + Django</a></li>\n<li><a href=\"https://medium.com/@yehandjoe/celery-4-periodic-task-in-django-9f6b5a8c21c7\">Celery 4 Periodic Task in Django</a></li>\n</ol>", "markdown": "This tutorial describes how to setup celery tasks scheduler for django app with django\u2019s admin interface for the purpose (tasks scheduling).\r\n\r\nThis tutorial consists of 3 parts: installation, configuration and instructions what to do next.\r\n\r\n## Installation\r\n\r\nRun the following commands in your venv:\r\n<pre class=\"command-line language-bash\" data-user=\"(env) user\" data-host=\"server\"><code class=\" language-bash\">\r\npip install -U \"celery[redis]\"\r\npip install django-celery-beat\r\npip install django-celery-result\r\n</code></pre>\r\n\r\n## Configuration\r\nLet\u2019s create script with configs for celery. We have similar to the following project structure at the moment of writing this tutorial.\r\n\r\n```language-bash\r\n...\r\nmanage.py\r\napps\r\nbase\r\n- tasks\r\n- - task01.py\r\n- - task02.py\r\n- celeryconf.py\r\n...\r\n```\r\n\r\n**celeryconf.py**\r\n\r\n<pre class=\"language-python line-numbers\"><code class=\" language-python line-numbers\">\r\nimport os\r\nfrom celery import Celery\r\nfrom kombu import Queue, Exchange\r\napp = Celery('tasks')\r\ndefault_exchange = Exchange('default', type='direct')\r\napp.conf.task_queues = (\r\n    Queue('default', default_exchange, routing_key='default'),\r\n)\r\napp.conf.task_default_queue = 'default'\r\napp.conf.task_default_exchange = 'default'\r\napp.conf.task_default_exchange_type = 'direct'\r\napp.conf.task_default_routing_key = 'default'\r\napp.conf.task_queues = (\r\n    Queue('default', default_exchange, routing_key='default'),\r\n)\r\napp.conf.beat_scheduler = 'django_celery_beat.schedulers:DatabaseScheduler'\r\nos.environ.setdefault('DJANGO_SETTINGS_MODULE', 'base.settings')\r\napp.config_from_object('django.conf:settings', namespace='CELERY')\r\napp.autodiscover_tasks()\r\n# hack for celery beat\r\nimport django\r\ndjango.setup()\r\n</code></pre>\r\n\r\n**tasks/__init__.py**\r\n<pre class=\"language-python line-numbers\"><code class=\" language-python line-numbers\">\r\nfrom celery import shared_task\r\nfrom celery.utils.log import get_task_logger\r\nlogger = get_task_logger(__name__)\r\n\r\n\r\n@shared_task\r\ndef parse_admitad_yml(channel_id=56):\r\n\r\n    from .parse_admitad_yml import ParseAdmitadYml\r\n\r\n    logger.info('Running parse_admitad_yml for channel_id %s', channel_id)\r\n    parser = ParseAdmitadYml()\r\n    try:\r\n        parser.execute(channel_id)\r\n    except Exception:\r\n        return 1\r\n\r\n    return 0\r\n\r\n\r\n@shared_task\r\ndef create_things():\r\n\r\n    from .create_things import CreateThings\r\n\r\n    logger.info('Running create_things')\r\n\r\n    try:\r\n        create_things = CreateThings()\r\n        create_things.execute()\r\n    except Exception:\r\n        return 1\r\n\r\n    return 0\r\n\r\n\r\n@shared_task\r\ndef create_things_auto():\r\n    from .create_things_auto import CreateThingsAuto\r\n\r\n    logger.info('Running create_things_auto')\r\n\r\n    try:\r\n        create_things_auto = CreateThingsAuto()\r\n        create_things_auto.execute()\r\n    except Exception:\r\n        return 1\r\n\r\n    return 0\r\n\r\n\r\n@shared_task\r\ndef add_pictures_to_things():\r\n    from .add_pictures_to_things import AddPicturesToThings\r\n\r\n    logger.info('Running add_pictures_to_things')\r\n\r\n    try:\r\n        add_pictures_to_things = AddPicturesToThings()\r\n        add_pictures_to_things.execute()\r\n    except Exception:\r\n        return 1\r\n\r\n    return 0\r\n</code></pre>\r\n\r\n**tasks/task01.py**\r\n<pre class=\"language-python line-numbers\"><code class=\" language-python line-numbers\">\r\n\\# coding: utf-8\r\nfrom django.core.management.base import NoArgsCommand\r\nfrom django.utils.translation import activate\r\nfrom admitad.models import Thing\r\n\r\n\r\nclass CreateThings:\r\n    \"\"\"A class for a celery task\"\"\"\r\n    def execute():\r\n        Thing.create_shop_things()\r\n</code></pre>\r\n\r\nStart redis server with\r\n<pre class=\"command-line language-bash\" data-user=\"user\" data-host=\"server\"><code class=\" language-bash\">\r\nredis-server\r\n</code></pre>\r\n\r\nStart a celery worker (executes the tasks) with the command:\r\n<pre class=\"command-line language-bash\" data-user=\"(env) user\" data-host=\"server\"><code class=\" language-bash\">\r\ncelery -A base.celeryconf worker -l info\r\n</code></pre>\r\n\r\nThen start a celery beat (adds tasks to the celery  queue) with the command:\r\n<pre class=\"command-line language-bash\" data-user=\"(env) user\" data-host=\"server\"><code class=\" language-bash\">\r\ncelery -A base.celeryconf beat -l info\r\n</code></pre>\r\n\r\n### The final words\r\n\r\nIf you completed the steps described above, you must have the celery setup for your django application up and running. All that lasts is to daemonize things. You should run the redis server, celery worker and beat in daemon mode (as background processes) for the task scheduling system to work using django admin interface. For more info on the subject see celery docs.\r\n\r\n## Sources:\r\n1. [Celery 4.1.0 documentation](http://docs.celeryproject.org/en/latest/index.html)\r\n2. [Celery + Redis + Django](https://www.codingforentrepreneurs.com/blog/celery-redis-django/)\r\n3. [Celery 4 Periodic Task in Django](https://medium.com/@yehandjoe/celery-4-periodic-task-in-django-9f6b5a8c21c7)", "minutes_to_read": 10, "created_at": "2017-12-08T16:09:59.183Z", "updated_at": "2017-12-09T07:14:41.861Z", "published_at": "2017-12-08T15:58:48Z", "status": "published"}}, {"model": "post.post", "pk": 4, "fields": {"title": "How to use Google Authenticator to make ssh less accessible", "slug": "how-use-google-authenticator-make-ssh-less-accessible", "excerpt": "This post tells how to set up Google Autheticator service to add one more step when login via ssh. The step requires to enter time based token (6-digit code) which expires every 30 seconds each time you login to your server remotely (not via hosting panel).", "body": "<h3>Introduction</h3>\n<p>OATH-TOTP (Open Authentication Time-Based One-Time Password) is an open protocol that generates a one-time use password, commonly a 6 digit number that is recycled every 30 seconds.</p>\n<p>Google Authenticator is a software token that implements two-step verification services using the Time-based One-time Password Algorithm (TOTP) and HMAC-based One-time Password Algorithm (HOTP), for authenticating users of mobile applications by Google. The service implements algorithms specified in RFC 6238 and RFC 4226. </p>\n<p>Authenticator provides a six- to eight-digit one-time password which users must provide in addition to their username and password to log into Google services or other sites. The Authenticator can also generate codes for third-party applications, such as password managers or file hosting services. Previous versions of the software were open-sourced but subsequent releases are proprietary.</p>\n<h3>Prerequisites</h3>\n<p>Completion of my <a href=\"https://maksimmanylow.com/post/how-protect-your-server-ubuntu-1604-fail2ban-email-alerts-geoip-filter.html\">first tutorial</a> and a smartphone or tablet with an OATH-TOTP app installed, like Google Authenticator (iOS, Android) is enough.</p>\n<h3>Contents</h3>\n<p>This tutorial includes these parts:</p>\n<ol>\n<li>Installing Google's PAM</li>\n<li>Configuring OpenSSH</li>\n<li>Making SSH Aware of MFA</li>\n<li>Adding a Third Factor (Optional)</li>\n</ol>\n<h2>1. Installing Google's PAM</h2>\n<p>In this step, we'll install and configure Google's PAM.</p>\n<p>PAM, which stands for Pluggable Authentication Module, is an authentication infrastructure used on Linux systems to authenticate a user. Because Google made an OATH-TOTP app, they also made a PAM that generates TOTPs and is fully compatible with any OATH-TOTP app, like Google Authenticator or Authy.</p>\n<p>First, update Ubuntu's repository cache.</p>\n<pre class=\"command-line language-bash\" data-user=\"user\" data-host=\"server\"><code class=\" language-bash\">\nsudo apt-get update\n</code></pre>\n\n<p>Next, install the PAM.</p>\n<pre class=\"command-line language-bash\" data-user=\"user\" data-host=\"server\"><code class=\" language-bash\">\nsudo apt-get install libpam-google-authenticator\n</code></pre>\n\n<p>Then download the app (i.e., Google Autheticator) on your mobile device (ios or android) and run the following command.</p>\n<pre class=\"command-line language-bash\" data-user=\"user\" data-host=\"server\"><code class=\" language-bash\">\ngoogle-authenticator\n</code></pre>\n\n<p>You should see a QR-code while completing the initialization process. In your app add the code tapping on the cross sign, scanning the code. Now you must see new record in the app with token which circles every 30 seconds.</p>\n<h2>2. Configuring OpenSSH</h2>\n<p>To enable authorization with TOTP (Time-Based One-Time Password) <code>sshd</code> service must be configured accordingly. Edit the configuration file with the following command.</p>\n<pre class=\"command-line language-bash\" data-user=\"user\" data-host=\"server\"><code class=\" language-bash\">\nsudo vim /etc/pam.d/sshd\n</code></pre>\n\n<p>Add the following line to the bottom of the file.</p>\n<pre><code class=\"language-bash\">. . .\n# Standard Un*x password updating.\n@include common-password\nauth required pam_google_authenticator.so nullok\n</code></pre>\n\n<p>The <code>nullok</code> word at the end of the last line tells the PAM that this authentication method is <em>optional</em>. This allows users <em>without</em> a OATH-TOTP token to still <em>log in</em> using their <em>SSH key</em>. Once all users have an OATH-TOTP token, you can remove nullok from this line to make MFA mandatory.</p>\n<p>Save and close the file.</p>\n<p>Next, we'll configure SSH to support this kind of authentication. Open the SSH configuration file for editing.</p>\n<pre class=\"command-line language-bash\" data-user=\"user\" data-host=\"server\"><code class=\" language-bash\">\nsudo vim /etc/ssh/sshd_config\n</code></pre>\n\n<p>Look for <code>ChallengeResponseAuthentication</code> and set its value to <code>yes</code>.</p>\n<pre><code class=\"language-bash\">. . .\n# Change to yes to enable challenge-response passwords (beware issues with\n# some PAM modules and threads)\nChallengeResponseAuthentication yes\n. . .\n</code></pre>\n\n<p>Restart <code>sshd</code> service</p>\n<pre class=\"command-line language-bash\" data-user=\"user\" data-host=\"server\"><code class=\" language-bash\">\nsudo systemctl restart sshd.service\n</code></pre>\n\n<h2>3. Making SSH Aware of MFA</h2>\n<p>Reopen the sshd configuration file.</p>\n<pre class=\"command-line language-bash\" data-user=\"user\" data-host=\"server\"><code class=\" language-bash\">\nsudo vim /etc/ssh/sshd_config\n</code></pre>\n\n<p>Add the following line at the bottom of the file. This tells SSH which authentication methods are required. This line tells SSH we need a SSH key and either a password or a verification code (or all three).</p>\n<pre><code class=\"language-bash\">. . .\nUsePAM yes\nAuthenticationMethods publickey,password publickey,keyboard-interactive\n</code></pre>\n\n<p>Save and close the file, then restart SSH.</p>\n<pre class=\"command-line language-bash\" data-user=\"user\" data-host=\"server\"><code class=\" language-bash\">\nsudo systemctl restart sshd.service\n</code></pre>\n\n<h2>4. Adding a Third Factor (Optional)</h2>\n<p>In Step 3, we listed the approved types of authentication in the sshd_config file:</p>\n<ol>\n<li>publickey (SSH key)</li>\n<li>password publickey (password)</li>\n<li>keyboard-interactive (verification code)</li>\n</ol>\n<p>Although we listed three different factors, with the options we've chosen so far, they only allow for an SSH key and the verification code. If you'd like to have all three factors (SSH key, password, and verification code), one quick change will enable all three.</p>\n<p>Open the PAM sshd configuration file.</p>\n<pre class=\"command-line language-bash\" data-user=\"user\" data-host=\"server\"><code class=\" language-bash\">\nsudo vim /etc/pam.d/sshd\n</code></pre>\n\n<p>Locate the line you commented out previously, <code>#@include common-auth</code>, and uncomment the line by removing the # character. Save and close the file. Now once again, restart SSH.</p>\n<pre class=\"command-line language-bash\" data-user=\"user\" data-host=\"server\"><code class=\" language-bash\">\nsudo systemctl restart sshd.service\n</code></pre>\n\n<p>By enabling the option <code>@include common-auth</code>, PAM will now prompt for a password in addition the checking for an SSH key and asking for a verification code, which we had working previously. Now we can use something we know (password) and two different types of things we have (SSH key and verification code) over two different channels.</p>\n<h2>Sources:</h2>\n<ol>\n<li><a href=\"https://www.digitalocean.com/community/tutorials/how-to-set-up-multi-factor-authentication-for-ssh-on-ubuntu-16-04\">How To Set Up Multi-Factor Authentication for SSH on Ubuntu 16.04</a></li>\n</ol>", "markdown": "### Introduction\r\n\r\nOATH-TOTP (Open Authentication Time-Based One-Time Password) is an open protocol that generates a one-time use password, commonly a 6 digit number that is recycled every 30 seconds.\r\n\r\nGoogle Authenticator is a software token that implements two-step verification services using the Time-based One-time Password Algorithm (TOTP) and HMAC-based One-time Password Algorithm (HOTP), for authenticating users of mobile applications by Google. The service implements algorithms specified in RFC 6238 and RFC 4226. \r\n\r\nAuthenticator provides a six- to eight-digit one-time password which users must provide in addition to their username and password to log into Google services or other sites. The Authenticator can also generate codes for third-party applications, such as password managers or file hosting services. Previous versions of the software were open-sourced but subsequent releases are proprietary.\r\n\r\n### Prerequisites\r\n\r\nCompletion of my [first tutorial](https://maksimmanylow.com/post/how-protect-your-server-ubuntu-1604-fail2ban-email-alerts-geoip-filter.html) and a smartphone or tablet with an OATH-TOTP app installed, like Google Authenticator (iOS, Android) is enough.\r\n\r\n### Contents\r\n\r\nThis tutorial includes these parts:\r\n\r\n1. Installing Google's PAM\r\n2. Configuring OpenSSH\r\n3. Making SSH Aware of MFA\r\n4. Adding a Third Factor (Optional)\r\n\r\n## 1. Installing Google's PAM\r\n\r\nIn this step, we'll install and configure Google's PAM.\r\n\r\nPAM, which stands for Pluggable Authentication Module, is an authentication infrastructure used on Linux systems to authenticate a user. Because Google made an OATH-TOTP app, they also made a PAM that generates TOTPs and is fully compatible with any OATH-TOTP app, like Google Authenticator or Authy.\r\n\r\nFirst, update Ubuntu's repository cache.\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"user\" data-host=\"server\"><code class=\" language-bash\">\r\nsudo apt-get update\r\n</code></pre>\r\n\r\n\r\nNext, install the PAM.\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"user\" data-host=\"server\"><code class=\" language-bash\">\r\nsudo apt-get install libpam-google-authenticator\r\n</code></pre>\r\n\r\nThen download the app (i.e., Google Autheticator) on your mobile device (ios or android) and run the following command.\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"user\" data-host=\"server\"><code class=\" language-bash\">\r\ngoogle-authenticator\r\n</code></pre>\r\n\r\nYou should see a QR-code while completing the initialization process. In your app add the code tapping on the cross sign, scanning the code. Now you must see new record in the app with token which circles every 30 seconds.\r\n\r\n\r\n## 2. Configuring OpenSSH\r\n\r\nTo enable authorization with TOTP (Time-Based One-Time Password) ```sshd``` service must be configured accordingly. Edit the configuration file with the following command.\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"user\" data-host=\"server\"><code class=\" language-bash\">\r\nsudo vim /etc/pam.d/sshd\r\n</code></pre>\r\n\r\nAdd the following line to the bottom of the file.\r\n\r\n```language-bash\r\n. . .\r\n# Standard Un*x password updating.\r\n@include common-password\r\nauth required pam_google_authenticator.so nullok\r\n```\r\n\r\nThe ```nullok``` word at the end of the last line tells the PAM that this authentication method is *optional*. This allows users *without* a OATH-TOTP token to still *log in* using their *SSH key*. Once all users have an OATH-TOTP token, you can remove nullok from this line to make MFA mandatory.\r\n\r\nSave and close the file.\r\n\r\nNext, we'll configure SSH to support this kind of authentication. Open the SSH configuration file for editing.\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"user\" data-host=\"server\"><code class=\" language-bash\">\r\nsudo vim /etc/ssh/sshd_config\r\n</code></pre>\r\n\r\nLook for ```ChallengeResponseAuthentication``` and set its value to ```yes```.\r\n\r\n```language-bash\r\n. . .\r\n# Change to yes to enable challenge-response passwords (beware issues with\r\n# some PAM modules and threads)\r\nChallengeResponseAuthentication yes\r\n. . .\r\n```\r\n\r\nRestart ```sshd``` service\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"user\" data-host=\"server\"><code class=\" language-bash\">\r\nsudo systemctl restart sshd.service\r\n</code></pre>\r\n\r\n## 3. Making SSH Aware of MFA\r\n\r\nReopen the sshd configuration file.\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"user\" data-host=\"server\"><code class=\" language-bash\">\r\nsudo vim /etc/ssh/sshd_config\r\n</code></pre>\r\n\r\nAdd the following line at the bottom of the file. This tells SSH which authentication methods are required. This line tells SSH we need a SSH key and either a password or a verification code (or all three).\r\n\r\n```language-bash\r\n. . .\r\nUsePAM yes\r\nAuthenticationMethods publickey,password publickey,keyboard-interactive\r\n```\r\n\r\nSave and close the file, then restart SSH.\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"user\" data-host=\"server\"><code class=\" language-bash\">\r\nsudo systemctl restart sshd.service\r\n</code></pre>\r\n\r\n## 4. Adding a Third Factor (Optional)\r\n\r\nIn Step 3, we listed the approved types of authentication in the sshd_config file:\r\n\r\n1. publickey (SSH key)\r\n2. password publickey (password)\r\n3. keyboard-interactive (verification code)\r\n\r\nAlthough we listed three different factors, with the options we've chosen so far, they only allow for an SSH key and the verification code. If you'd like to have all three factors (SSH key, password, and verification code), one quick change will enable all three.\r\n\r\nOpen the PAM sshd configuration file.\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"user\" data-host=\"server\"><code class=\" language-bash\">\r\nsudo vim /etc/pam.d/sshd\r\n</code></pre>\r\n\r\nLocate the line you commented out previously, ```#@include common-auth```, and uncomment the line by removing the # character. Save and close the file. Now once again, restart SSH.\r\n\r\n<pre class=\"command-line language-bash\" data-user=\"user\" data-host=\"server\"><code class=\" language-bash\">\r\nsudo systemctl restart sshd.service\r\n</code></pre>\r\n\r\n\r\nBy enabling the option ```@include common-auth```, PAM will now prompt for a password in addition the checking for an SSH key and asking for a verification code, which we had working previously. Now we can use something we know (password) and two different types of things we have (SSH key and verification code) over two different channels.\r\n\r\n\r\n## Sources:\r\n\r\n1. [How To Set Up Multi-Factor Authentication for SSH on Ubuntu 16.04](https://www.digitalocean.com/community/tutorials/how-to-set-up-multi-factor-authentication-for-ssh-on-ubuntu-16-04)", "minutes_to_read": 5, "created_at": "2017-12-29T21:50:12.843Z", "updated_at": "2017-12-29T23:35:12.272Z", "published_at": "2017-12-29T20:12:35Z", "status": "published"}}]